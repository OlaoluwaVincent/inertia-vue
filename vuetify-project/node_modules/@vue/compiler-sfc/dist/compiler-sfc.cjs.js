/**
* @vue/compiler-sfc v3.4.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var compilerCore = require('@vue/compiler-core');
var CompilerDOM = require('@vue/compiler-dom');
var sourceMapJs = require('source-map-js');
var path$3 = require('path');
var shared = require('@vue/shared');
var url = require('url');
var CompilerSSR = require('@vue/compiler-ssr');
var require$$2 = require('util');
var require$$0 = require('fs');
var require$$0$1 = require('postcss');
var estreeWalker = require('estree-walker');
var MagicString = require('magic-string');
var parser$1 = require('@babel/parser');
var process$1 = require('process');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    for (var k in e) {
      n[k] = e[k];
    }
  }
  n.default = e;
  return Object.freeze(n);
}

var CompilerDOM__namespace = /*#__PURE__*/_interopNamespaceDefault(CompilerDOM);
var CompilerSSR__namespace = /*#__PURE__*/_interopNamespaceDefault(CompilerSSR);
var process__namespace = /*#__PURE__*/_interopNamespaceDefault(process$1);

const UNKNOWN_TYPE = "Unknown";
function resolveObjectKey(node, computed) {
  switch (node.type) {
    case "StringLiteral":
    case "NumericLiteral":
      return String(node.value);
    case "Identifier":
      if (!computed)
        return node.name;
  }
  return void 0;
}
function concatStrings(strs) {
  return strs.filter((s) => !!s).join(", ");
}
function isLiteralNode(node) {
  return node.type.endsWith("Literal");
}
function isCallOf(node, test) {
  return !!(node && test && node.type === "CallExpression" && node.callee.type === "Identifier" && (typeof test === "string" ? node.callee.name === test : test(node.callee.name)));
}
function toRuntimeTypeString(types) {
  return types.length > 1 ? `[${types.join(", ")}]` : types[0];
}
function getImportedName(specifier) {
  if (specifier.type === "ImportSpecifier")
    return specifier.imported.type === "Identifier" ? specifier.imported.name : specifier.imported.value;
  else if (specifier.type === "ImportNamespaceSpecifier")
    return "*";
  return "default";
}
function getId(node) {
  return node.type === "Identifier" ? node.name : node.type === "StringLiteral" ? node.value : null;
}
const identity = (str) => str;
const fileNameLowerCaseRegExp = /[^\u0130\u0131\u00DFa-z0-9\\/:\-_\. ]+/g;
const toLowerCase = (str) => str.toLowerCase();
function toFileNameLowerCase(x) {
  return fileNameLowerCaseRegExp.test(x) ? x.replace(fileNameLowerCaseRegExp, toLowerCase) : x;
}
function createGetCanonicalFileName(useCaseSensitiveFileNames) {
  return useCaseSensitiveFileNames ? identity : toFileNameLowerCase;
}
const normalize = (path$3.posix || path$3).normalize;
const windowsSlashRE = /\\/g;
function normalizePath(p) {
  return normalize(p.replace(windowsSlashRE, "/"));
}
const joinPaths = (path$3.posix || path$3).join;
const propNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~\-]/;
function getEscapedPropName(key) {
  return propNameEscapeSymbolsRE.test(key) ? JSON.stringify(key) : key;
}
const cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function getEscapedCssVarName(key, doubleEscape) {
  return key.replace(
    cssVarNameEscapeSymbolsRE,
    (s) => doubleEscape ? `\\\\${s}` : `\\${s}`
  );
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function pad (hash, len) {
  while (hash.length < len) {
    hash = '0' + hash;
  }
  return hash;
}

function fold (hash, text) {
  var i;
  var chr;
  var len;
  if (text.length === 0) {
    return hash;
  }
  for (i = 0, len = text.length; i < len; i++) {
    chr = text.charCodeAt(i);
    hash = ((hash << 5) - hash) + chr;
    hash |= 0;
  }
  return hash < 0 ? hash * -2 : hash;
}

function foldObject (hash, o, seen) {
  return Object.keys(o).sort().reduce(foldKey, hash);
  function foldKey (hash, key) {
    return foldValue(hash, o[key], key, seen);
  }
}

function foldValue (input, value, key, seen) {
  var hash = fold(fold(fold(input, key), toString$1(value)), typeof value);
  if (value === null) {
    return fold(hash, 'null');
  }
  if (value === undefined) {
    return fold(hash, 'undefined');
  }
  if (typeof value === 'object' || typeof value === 'function') {
    if (seen.indexOf(value) !== -1) {
      return fold(hash, '[Circular]' + key);
    }
    seen.push(value);

    var objHash = foldObject(hash, value, seen);

    if (!('valueOf' in value) || typeof value.valueOf !== 'function') {
      return objHash;
    }

    try {
      return fold(objHash, String(value.valueOf()))
    } catch (err) {
      return fold(objHash, '[valueOf exception]' + (err.stack || err.message))
    }
  }
  return fold(hash, value.toString());
}

function toString$1 (o) {
  return Object.prototype.toString.call(o);
}

function sum (o) {
  return pad(foldValue(0, o, '', []).toString(16), 8);
}

var hashSum = sum;

var hash$1 = /*@__PURE__*/getDefaultExportFromCjs(hashSum);

const CSS_VARS_HELPER = `useCssVars`;
function genCssVarsFromList(vars, id, isProd, isSSR = false) {
  return `{
  ${vars.map(
    (key) => `"${isSSR ? `--` : ``}${genVarName(id, key, isProd, isSSR)}": (${key})`
  ).join(",\n  ")}
}`;
}
function genVarName(id, raw, isProd, isSSR = false) {
  if (isProd) {
    return hash$1(id + raw);
  } else {
    return `${id}-${getEscapedCssVarName(raw, isSSR)}`;
  }
}
function normalizeExpression(exp) {
  exp = exp.trim();
  if (exp[0] === `'` && exp[exp.length - 1] === `'` || exp[0] === `"` && exp[exp.length - 1] === `"`) {
    return exp.slice(1, -1);
  }
  return exp;
}
const vBindRE = /v-bind\s*\(/g;
function parseCssVars(sfc) {
  const vars = [];
  sfc.styles.forEach((style) => {
    let match;
    const content = style.content.replace(/\/\*([\s\S]*?)\*\/|\/\/.*/g, "");
    while (match = vBindRE.exec(content)) {
      const start = match.index + match[0].length;
      const end = lexBinding(content, start);
      if (end !== null) {
        const variable = normalizeExpression(content.slice(start, end));
        if (!vars.includes(variable)) {
          vars.push(variable);
        }
      }
    }
  });
  return vars;
}
function lexBinding(content, start) {
  let state = 0 /* inParens */;
  let parenDepth = 0;
  for (let i = start; i < content.length; i++) {
    const char = content.charAt(i);
    switch (state) {
      case 0 /* inParens */:
        if (char === `'`) {
          state = 1 /* inSingleQuoteString */;
        } else if (char === `"`) {
          state = 2 /* inDoubleQuoteString */;
        } else if (char === `(`) {
          parenDepth++;
        } else if (char === `)`) {
          if (parenDepth > 0) {
            parenDepth--;
          } else {
            return i;
          }
        }
        break;
      case 1 /* inSingleQuoteString */:
        if (char === `'`) {
          state = 0 /* inParens */;
        }
        break;
      case 2 /* inDoubleQuoteString */:
        if (char === `"`) {
          state = 0 /* inParens */;
        }
        break;
    }
  }
  return null;
}
const cssVarsPlugin = (opts) => {
  const { id, isProd } = opts;
  return {
    postcssPlugin: "vue-sfc-vars",
    Declaration(decl) {
      const value = decl.value;
      if (vBindRE.test(value)) {
        vBindRE.lastIndex = 0;
        let transformed = "";
        let lastIndex = 0;
        let match;
        while (match = vBindRE.exec(value)) {
          const start = match.index + match[0].length;
          const end = lexBinding(value, start);
          if (end !== null) {
            const variable = normalizeExpression(value.slice(start, end));
            transformed += value.slice(lastIndex, match.index) + `var(--${genVarName(id, variable, isProd)})`;
            lastIndex = end + 1;
          }
        }
        decl.value = transformed + value.slice(lastIndex);
      }
    }
  };
};
cssVarsPlugin.postcss = true;
function genCssVarsCode(vars, bindings, id, isProd) {
  const varsExp = genCssVarsFromList(vars, id, isProd);
  const exp = CompilerDOM.createSimpleExpression(varsExp, false);
  const context = CompilerDOM.createTransformContext(CompilerDOM.createRoot([]), {
    prefixIdentifiers: true,
    inline: true,
    bindingMetadata: bindings.__isScriptSetup === false ? void 0 : bindings
  });
  const transformed = CompilerDOM.processExpression(exp, context);
  const transformedString = transformed.type === 4 ? transformed.content : transformed.children.map((c) => {
    return typeof c === "string" ? c : c.content;
  }).join("");
  return `_${CSS_VARS_HELPER}(_ctx => (${transformedString}))`;
}
function genNormalScriptCssVarsCode(cssVars, bindings, id, isProd, defaultVar) {
  return `
import { ${CSS_VARS_HELPER} as _${CSS_VARS_HELPER} } from 'vue'
const __injectCSSVars__ = () => {
${genCssVarsCode(
    cssVars,
    bindings,
    id,
    isProd
  )}}
const __setup__ = ${defaultVar}.setup
${defaultVar}.setup = __setup__
  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }
  : __injectCSSVars__
`;
}

/**
 * @module LRUCache
 */
const perf = typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function'
    ? performance
    : Date;
const warned = new Set();
/* c8 ignore start */
const PROCESS = (typeof process === 'object' && !!process ? process : {});
/* c8 ignore start */
const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function'
        ? PROCESS.emitWarning(msg, type, code, fn)
        : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor() {
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted)
                return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' +
            'node 14, load an AbortController polyfill from the ' +
            '`node-abort-controller` package. A minimal polyfill is ' +
            'provided for use by LRUCache.fetch(), but it should not be ' +
            'relied upon in other contexts (eg, passing it to other APIs that ' +
            'use AbortController/AbortSignal might have undesirable effects). ' +
            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */
const shouldWarn = (code) => !warned.has(code);
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
// This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max) => !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
        ? Uint8Array
        : max <= Math.pow(2, 16)
            ? Uint16Array
            : max <= Math.pow(2, 32)
                ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER
                    ? ZeroArray
                    : null;
/* c8 ignore stop */
class ZeroArray extends Array {
    constructor(size) {
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
            return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls) {
        /* c8 ignore start */
        if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */
        this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * All properties from the options object (with the exception of
 * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as
 * normal public members. (`max` and `maxBase` are read-only getters.)
 * Changing any of these will alter the defaults for subsequent method calls,
 * but is otherwise safe.
 */
class LRUCache {
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
                return c.#head;
            },
            get tail() {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return this.#fetchMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (fetchMethod !== undefined &&
            typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        }
        else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0
                ? ttlResolution
                : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                    'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the remaining TTL time for a given entry key
     */
    getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(() => {
                    if (this.#isStale(index)) {
                        this.delete(this.#keyList[index]);
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
        };
        this.#updateItemAge = index => {
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */
                if (!ttl || !start)
                    return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = () => {
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
            return n;
        };
        this.getRemainingTTL = key => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = index => {
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => { };
    #statusTTL = () => { };
    #setItemTTL = () => { };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = index => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                }
                else {
                    throw new TypeError('invalid size value (must be positive integer). ' +
                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
                        'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while (this.#calculatedSize > maxSize) {
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = _i => { };
    #addItemSize = (_i, _s, _st) => { };
    #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#tail; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                }
                else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#head; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                }
                else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return (index !== undefined &&
            this.#keyMap.get(this.#keyList[index]) === index);
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
        for (const i of this.#indexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
        for (const i of this.#rindexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
        for (const i of this.#indexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
        for (const i of this.#rindexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to Array.find().  fn is called as fn(value, key, cache).
     */
    find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from
     * most recently used to least recently used.  fn is called as
     * fn(value, key, cache).  Does not update age or recenty of use.
     * Does not iterate over stale values.
     */
    forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i)) {
                this.delete(this.#keyList[i]);
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
     * single key. Always returns stale values, if their info is found in the
     * cache, so be sure to check for expired TTLs if relevant.
     */
    info(key) {
        const i = this.#keyMap.get(key);
        if (i === undefined)
            return undefined;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v)
            ? v.__staleWhileFetching
            : v;
        if (value === undefined)
            return undefined;
        const entry = { value };
        if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
                const remain = ttl - (perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (this.#sizes) {
            entry.size = this.#sizes[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to cache.load()
     */
    dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined || key === undefined)
                continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([key, entry]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     * Note that the shape of the resulting cache may be different if the
     * same options are not used in both caches.
     */
    load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     */
    set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.delete(k);
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = (this.#size === 0
                ? this.#tail
                : this.#free.length !== 0
                    ? this.#free.pop()
                    : this.#size === this.#max
                        ? this.#evict(false)
                        : this.#size);
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status)
                status.set = 'add';
            noUpdateTTL = false;
        }
        else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([s, k, 'set']);
                        }
                    }
                }
                else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([oldVal, k, 'set']);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)
                        ? oldVal.__staleWhileFetching
                        : oldVal;
                    if (oldValue !== undefined)
                        status.oldValue = oldValue;
                }
            }
            else if (status) {
                status.set = 'update';
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status)
                this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
        try {
            while (this.#size) {
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                }
                else if (val !== undefined) {
                    return val;
                }
            }
        }
        finally {
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while ((task = dt?.shift())) {
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        }
        else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, 'evict']);
            }
        }
        this.#removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        }
        else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) &&
                v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            }
            else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        }
        else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === undefined ||
            (!allowStale && this.#isStale(index))) {
            return;
        }
        const v = this.#valList[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
            signal: ac.signal,
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context,
        };
        const cb = (v, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort)
                        options.status.fetchAbortIgnored = true;
                }
                else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            if (this.#valList[index] === p) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    }
                    else {
                        this.delete(k);
                    }
                }
                else {
                    if (options.status)
                        options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er) => {
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.delete(k);
                }
                else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            }
            else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then(v => res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', () => {
                if (!options.ignoreFetchAbort ||
                    options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = v => cb(v, true);
                    }
                }
            });
        };
        if (options.status)
            options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
        }
        else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
            return false;
        const b = p;
        return (!!b &&
            b instanceof Promise &&
            b.hasOwnProperty('__staleWhileFetching') &&
            b.__abortController instanceof AC);
    }
    async fetch(k, fetchOptions = {}) {
        const { 
        // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
        // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status)
                status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status,
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status)
                status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
        }
        else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale)
                        status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status)
                    status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status)
                    this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale)
                    status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
        }
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status)
                this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status)
                    status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.delete(k);
                    }
                    if (status && allowStale)
                        status.returnedStale = true;
                    return allowStale ? value : undefined;
                }
                else {
                    if (status &&
                        allowStale &&
                        value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            }
            else {
                if (status)
                    status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        }
        else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            }
            else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.clear();
                }
                else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    }
                    else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, 'delete');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([v, k, 'delete']);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    }
                    else if (index === this.#head) {
                        this.#head = this.#next[index];
                    }
                    else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
        for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            }
            else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, 'delete');
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, 'delete']);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
    }
}

function createCache(max = 500) {
  return new LRUCache({ max });
}

function isImportUsed(local, sfc) {
  return resolveTemplateUsedIdentifiers(sfc).has(local);
}
const templateUsageCheckCache = createCache();
function resolveTemplateUsedIdentifiers(sfc) {
  const { content, ast } = sfc.template;
  const cached = templateUsageCheckCache.get(content);
  if (cached) {
    return cached;
  }
  const ids = /* @__PURE__ */ new Set();
  ast.children.forEach(walk);
  function walk(node) {
    var _a;
    switch (node.type) {
      case 1:
        let tag = node.tag;
        if (tag.includes("."))
          tag = tag.split(".")[0].trim();
        if (!CompilerDOM.parserOptions.isNativeTag(tag) && !CompilerDOM.parserOptions.isBuiltInComponent(tag)) {
          ids.add(shared.camelize(tag));
          ids.add(shared.capitalize(shared.camelize(tag)));
        }
        for (let i = 0; i < node.props.length; i++) {
          const prop = node.props[i];
          if (prop.type === 7) {
            if (!shared.isBuiltInDirective(prop.name)) {
              ids.add(`v${shared.capitalize(shared.camelize(prop.name))}`);
            }
            if (prop.arg && !prop.arg.isStatic) {
              extractIdentifiers(ids, prop.arg);
            }
            if (prop.name === "for") {
              extractIdentifiers(ids, prop.forParseResult.source);
            } else if (prop.exp) {
              extractIdentifiers(ids, prop.exp);
            } else if (prop.name === "bind" && !prop.exp) {
              ids.add(prop.arg.content);
            }
          }
          if (prop.type === 6 && prop.name === "ref" && ((_a = prop.value) == null ? void 0 : _a.content)) {
            ids.add(prop.value.content);
          }
        }
        node.children.forEach(walk);
        break;
      case 5:
        extractIdentifiers(ids, node.content);
        break;
    }
  }
  templateUsageCheckCache.set(content, ids);
  return ids;
}
function extractIdentifiers(ids, node) {
  if (node.ast) {
    CompilerDOM.walkIdentifiers(node.ast, (n) => ids.add(n.name));
  } else if (node.ast === null) {
    ids.add(node.content);
  }
}

const DEFAULT_FILENAME = "anonymous.vue";
const parseCache$1 = createCache();
function genCacheKey(source, options) {
  var _a;
  return source + JSON.stringify(
    {
      ...options,
      compiler: { parse: (_a = options.compiler) == null ? void 0 : _a.parse }
    },
    (_, val) => typeof val === "function" ? val.toString() : val
  );
}
function parse$2(source, options = {}) {
  const sourceKey = genCacheKey(source, options);
  const cache = parseCache$1.get(sourceKey);
  if (cache) {
    return cache;
  }
  const {
    sourceMap = true,
    filename = DEFAULT_FILENAME,
    sourceRoot = "",
    pad = false,
    ignoreEmpty = true,
    compiler = CompilerDOM__namespace,
    templateParseOptions = {},
    parseExpressions = true
  } = options;
  const descriptor = {
    filename,
    source,
    template: null,
    script: null,
    scriptSetup: null,
    styles: [],
    customBlocks: [],
    cssVars: [],
    slotted: false,
    shouldForceReload: (prevImports) => hmrShouldReload(prevImports, descriptor)
  };
  const errors = [];
  const ast = compiler.parse(source, {
    parseMode: "sfc",
    prefixIdentifiers: parseExpressions,
    ...templateParseOptions,
    onError: (e) => {
      errors.push(e);
    }
  });
  ast.children.forEach((node) => {
    if (node.type !== 1) {
      return;
    }
    if (ignoreEmpty && node.tag !== "template" && isEmpty(node) && !hasSrc(node)) {
      return;
    }
    switch (node.tag) {
      case "template":
        if (!descriptor.template) {
          const templateBlock = descriptor.template = createBlock(
            node,
            source,
            false
          );
          if (!templateBlock.attrs.src) {
            templateBlock.ast = compilerCore.createRoot(node.children, source);
          }
          if (templateBlock.attrs.functional) {
            const err = new SyntaxError(
              `<template functional> is no longer supported in Vue 3, since functional components no longer have significant performance difference from stateful ones. Just use a normal <template> instead.`
            );
            err.loc = node.props.find(
              (p) => p.type === 6 && p.name === "functional"
            ).loc;
            errors.push(err);
          }
        } else {
          errors.push(createDuplicateBlockError(node));
        }
        break;
      case "script":
        const scriptBlock = createBlock(node, source, pad);
        const isSetup = !!scriptBlock.attrs.setup;
        if (isSetup && !descriptor.scriptSetup) {
          descriptor.scriptSetup = scriptBlock;
          break;
        }
        if (!isSetup && !descriptor.script) {
          descriptor.script = scriptBlock;
          break;
        }
        errors.push(createDuplicateBlockError(node, isSetup));
        break;
      case "style":
        const styleBlock = createBlock(node, source, pad);
        if (styleBlock.attrs.vars) {
          errors.push(
            new SyntaxError(
              `<style vars> has been replaced by a new proposal: https://github.com/vuejs/rfcs/pull/231`
            )
          );
        }
        descriptor.styles.push(styleBlock);
        break;
      default:
        descriptor.customBlocks.push(createBlock(node, source, pad));
        break;
    }
  });
  if (!descriptor.template && !descriptor.script && !descriptor.scriptSetup) {
    errors.push(
      new SyntaxError(
        `At least one <template> or <script> is required in a single file component.`
      )
    );
  }
  if (descriptor.scriptSetup) {
    if (descriptor.scriptSetup.src) {
      errors.push(
        new SyntaxError(
          `<script setup> cannot use the "src" attribute because its syntax will be ambiguous outside of the component.`
        )
      );
      descriptor.scriptSetup = null;
    }
    if (descriptor.script && descriptor.script.src) {
      errors.push(
        new SyntaxError(
          `<script> cannot use the "src" attribute when <script setup> is also present because they must be processed together.`
        )
      );
      descriptor.script = null;
    }
  }
  let templateColumnOffset = 0;
  if (descriptor.template && (descriptor.template.lang === "pug" || descriptor.template.lang === "jade")) {
    [descriptor.template.content, templateColumnOffset] = dedent(
      descriptor.template.content
    );
  }
  if (sourceMap) {
    const genMap = (block, columnOffset = 0) => {
      if (block && !block.src) {
        block.map = generateSourceMap(
          filename,
          source,
          block.content,
          sourceRoot,
          !pad || block.type === "template" ? block.loc.start.line - 1 : 0,
          columnOffset
        );
      }
    };
    genMap(descriptor.template, templateColumnOffset);
    genMap(descriptor.script);
    descriptor.styles.forEach((s) => genMap(s));
    descriptor.customBlocks.forEach((s) => genMap(s));
  }
  descriptor.cssVars = parseCssVars(descriptor);
  const slottedRE = /(?:::v-|:)slotted\(/;
  descriptor.slotted = descriptor.styles.some(
    (s) => s.scoped && slottedRE.test(s.content)
  );
  const result = {
    descriptor,
    errors
  };
  parseCache$1.set(sourceKey, result);
  return result;
}
function createDuplicateBlockError(node, isScriptSetup = false) {
  const err = new SyntaxError(
    `Single file component can contain only one <${node.tag}${isScriptSetup ? ` setup` : ``}> element`
  );
  err.loc = node.loc;
  return err;
}
function createBlock(node, source, pad) {
  const type = node.tag;
  const loc = node.innerLoc;
  const attrs = {};
  const block = {
    type,
    content: source.slice(loc.start.offset, loc.end.offset),
    loc,
    attrs
  };
  if (pad) {
    block.content = padContent(source, block, pad) + block.content;
  }
  node.props.forEach((p) => {
    if (p.type === 6) {
      const name = p.name;
      attrs[name] = p.value ? p.value.content || true : true;
      if (name === "lang") {
        block.lang = p.value && p.value.content;
      } else if (name === "src") {
        block.src = p.value && p.value.content;
      } else if (type === "style") {
        if (name === "scoped") {
          block.scoped = true;
        } else if (name === "module") {
          block.module = attrs[name];
        }
      } else if (type === "script" && name === "setup") {
        block.setup = attrs.setup;
      }
    }
  });
  return block;
}
const splitRE = /\r?\n/g;
const emptyRE = /^(?:\/\/)?\s*$/;
const replaceRE = /./g;
function generateSourceMap(filename, source, generated, sourceRoot, lineOffset, columnOffset) {
  const map = new sourceMapJs.SourceMapGenerator({
    file: filename.replace(/\\/g, "/"),
    sourceRoot: sourceRoot.replace(/\\/g, "/")
  });
  map.setSourceContent(filename, source);
  map._sources.add(filename);
  generated.split(splitRE).forEach((line, index) => {
    if (!emptyRE.test(line)) {
      const originalLine = index + 1 + lineOffset;
      const generatedLine = index + 1;
      for (let i = 0; i < line.length; i++) {
        if (!/\s/.test(line[i])) {
          map._mappings.add({
            originalLine,
            originalColumn: i + columnOffset,
            generatedLine,
            generatedColumn: i,
            source: filename,
            name: null
          });
        }
      }
    }
  });
  return map.toJSON();
}
function padContent(content, block, pad) {
  content = content.slice(0, block.loc.start.offset);
  if (pad === "space") {
    return content.replace(replaceRE, " ");
  } else {
    const offset = content.split(splitRE).length;
    const padChar = block.type === "script" && !block.lang ? "//\n" : "\n";
    return Array(offset).join(padChar);
  }
}
function hasSrc(node) {
  return node.props.some((p) => {
    if (p.type !== 6) {
      return false;
    }
    return p.name === "src";
  });
}
function isEmpty(node) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (child.type !== 2 || child.content.trim() !== "") {
      return false;
    }
  }
  return true;
}
function hmrShouldReload(prevImports, next) {
  if (!next.scriptSetup || next.scriptSetup.lang !== "ts" && next.scriptSetup.lang !== "tsx") {
    return false;
  }
  for (const key in prevImports) {
    if (!prevImports[key].isUsedInTemplate && isImportUsed(key, next)) {
      return true;
    }
  }
  return false;
}
function dedent(s) {
  const lines = s.split("\n");
  const minIndent = lines.reduce(function(minIndent2, line) {
    var _a, _b;
    if (line.trim() === "") {
      return minIndent2;
    }
    const indent = ((_b = (_a = line.match(/^\s*/)) == null ? void 0 : _a[0]) == null ? void 0 : _b.length) || 0;
    return Math.min(indent, minIndent2);
  }, Infinity);
  if (minIndent === 0) {
    return [s, minIndent];
  }
  return [
    lines.map(function(line) {
      return line.slice(minIndent);
    }).join("\n"),
    minIndent
  ];
}

function isRelativeUrl(url) {
  const firstChar = url.charAt(0);
  return firstChar === "." || firstChar === "~" || firstChar === "@";
}
const externalRE = /^(https?:)?\/\//;
function isExternalUrl(url) {
  return externalRE.test(url);
}
const dataUrlRE = /^\s*data:/i;
function isDataUrl(url) {
  return dataUrlRE.test(url);
}
function parseUrl(url) {
  const firstChar = url.charAt(0);
  if (firstChar === "~") {
    const secondChar = url.charAt(1);
    url = url.slice(secondChar === "/" ? 2 : 1);
  }
  return parseUriParts(url);
}
function parseUriParts(urlString) {
  return url.parse(shared.isString(urlString) ? urlString : "", false, true);
}

const defaultAssetUrlOptions = {
  base: null,
  includeAbsolute: false,
  tags: {
    video: ["src", "poster"],
    source: ["src"],
    img: ["src"],
    image: ["xlink:href", "href"],
    use: ["xlink:href", "href"]
  }
};
const normalizeOptions = (options) => {
  if (Object.keys(options).some((key) => shared.isArray(options[key]))) {
    return {
      ...defaultAssetUrlOptions,
      tags: options
    };
  }
  return {
    ...defaultAssetUrlOptions,
    ...options
  };
};
const createAssetUrlTransformWithOptions = (options) => {
  return (node, context) => transformAssetUrl(node, context, options);
};
const transformAssetUrl = (node, context, options = defaultAssetUrlOptions) => {
  if (node.type === 1) {
    if (!node.props.length) {
      return;
    }
    const tags = options.tags || defaultAssetUrlOptions.tags;
    const attrs = tags[node.tag];
    const wildCardAttrs = tags["*"];
    if (!attrs && !wildCardAttrs) {
      return;
    }
    const assetAttrs = (attrs || []).concat(wildCardAttrs || []);
    node.props.forEach((attr, index) => {
      if (attr.type !== 6 || !assetAttrs.includes(attr.name) || !attr.value || isExternalUrl(attr.value.content) || isDataUrl(attr.value.content) || attr.value.content[0] === "#" || !options.includeAbsolute && !isRelativeUrl(attr.value.content)) {
        return;
      }
      const url = parseUrl(attr.value.content);
      if (options.base && attr.value.content[0] === ".") {
        const base = parseUrl(options.base);
        const protocol = base.protocol || "";
        const host = base.host ? protocol + "//" + base.host : "";
        const basePath = base.path || "/";
        attr.value.content = host + (path$3.posix || path$3).join(basePath, url.path + (url.hash || ""));
        return;
      }
      const exp = getImportsExpressionExp(url.path, url.hash, attr.loc, context);
      node.props[index] = {
        type: 7,
        name: "bind",
        arg: compilerCore.createSimpleExpression(attr.name, true, attr.loc),
        exp,
        modifiers: [],
        loc: attr.loc
      };
    });
  }
};
function getImportsExpressionExp(path2, hash, loc, context) {
  if (path2) {
    let name;
    let exp;
    const existingIndex = context.imports.findIndex((i) => i.path === path2);
    if (existingIndex > -1) {
      name = `_imports_${existingIndex}`;
      exp = context.imports[existingIndex].exp;
    } else {
      name = `_imports_${context.imports.length}`;
      exp = compilerCore.createSimpleExpression(
        name,
        false,
        loc,
        3
      );
      context.imports.push({
        exp,
        path: decodeURIComponent(path2)
      });
    }
    if (!hash) {
      return exp;
    }
    const hashExp = `${name} + '${hash}'`;
    const finalExp = compilerCore.createSimpleExpression(
      hashExp,
      false,
      loc,
      3
    );
    if (!context.hoistStatic) {
      return finalExp;
    }
    const existingHoistIndex = context.hoists.findIndex((h) => {
      return h && h.type === 4 && !h.isStatic && h.content === hashExp;
    });
    if (existingHoistIndex > -1) {
      return compilerCore.createSimpleExpression(
        `_hoisted_${existingHoistIndex + 1}`,
        false,
        loc,
        3
      );
    }
    return context.hoist(finalExp);
  } else {
    return compilerCore.createSimpleExpression(`''`, false, loc, 3);
  }
}

const srcsetTags = ["img", "source"];
const escapedSpaceCharacters = /( |\\t|\\n|\\f|\\r)+/g;
const createSrcsetTransformWithOptions = (options) => {
  return (node, context) => transformSrcset(node, context, options);
};
const transformSrcset = (node, context, options = defaultAssetUrlOptions) => {
  if (node.type === 1) {
    if (srcsetTags.includes(node.tag) && node.props.length) {
      node.props.forEach((attr, index) => {
        if (attr.name === "srcset" && attr.type === 6) {
          if (!attr.value)
            return;
          const value = attr.value.content;
          if (!value)
            return;
          const imageCandidates = value.split(",").map((s) => {
            const [url, descriptor] = s.replace(escapedSpaceCharacters, " ").trim().split(" ", 2);
            return { url, descriptor };
          });
          for (let i = 0; i < imageCandidates.length; i++) {
            const { url } = imageCandidates[i];
            if (isDataUrl(url)) {
              imageCandidates[i + 1].url = url + "," + imageCandidates[i + 1].url;
              imageCandidates.splice(i, 1);
            }
          }
          const shouldProcessUrl = (url) => {
            return !isExternalUrl(url) && !isDataUrl(url) && (options.includeAbsolute || isRelativeUrl(url));
          };
          if (!imageCandidates.some(({ url }) => shouldProcessUrl(url))) {
            return;
          }
          if (options.base) {
            const base = options.base;
            const set = [];
            let needImportTransform = false;
            imageCandidates.forEach((candidate) => {
              let { url, descriptor } = candidate;
              descriptor = descriptor ? ` ${descriptor}` : ``;
              if (url[0] === ".") {
                candidate.url = (path$3.posix || path$3).join(base, url);
                set.push(candidate.url + descriptor);
              } else if (shouldProcessUrl(url)) {
                needImportTransform = true;
              } else {
                set.push(url + descriptor);
              }
            });
            if (!needImportTransform) {
              attr.value.content = set.join(", ");
              return;
            }
          }
          const compoundExpression = compilerCore.createCompoundExpression([], attr.loc);
          imageCandidates.forEach(({ url, descriptor }, index2) => {
            if (shouldProcessUrl(url)) {
              const { path: path2 } = parseUrl(url);
              let exp2;
              if (path2) {
                const existingImportsIndex = context.imports.findIndex(
                  (i) => i.path === path2
                );
                if (existingImportsIndex > -1) {
                  exp2 = compilerCore.createSimpleExpression(
                    `_imports_${existingImportsIndex}`,
                    false,
                    attr.loc,
                    3
                  );
                } else {
                  exp2 = compilerCore.createSimpleExpression(
                    `_imports_${context.imports.length}`,
                    false,
                    attr.loc,
                    3
                  );
                  context.imports.push({ exp: exp2, path: path2 });
                }
                compoundExpression.children.push(exp2);
              }
            } else {
              const exp2 = compilerCore.createSimpleExpression(
                `"${url}"`,
                false,
                attr.loc,
                3
              );
              compoundExpression.children.push(exp2);
            }
            const isNotLast = imageCandidates.length - 1 > index2;
            if (descriptor && isNotLast) {
              compoundExpression.children.push(` + ' ${descriptor}, ' + `);
            } else if (descriptor) {
              compoundExpression.children.push(` + ' ${descriptor}'`);
            } else if (isNotLast) {
              compoundExpression.children.push(` + ', ' + `);
            }
          });
          let exp = compoundExpression;
          if (context.hoistStatic) {
            exp = context.hoist(compoundExpression);
            exp.constType = 3;
          }
          node.props[index] = {
            type: 7,
            name: "bind",
            arg: compilerCore.createSimpleExpression("srcset", true, attr.loc),
            exp,
            modifiers: [],
            loc: attr.loc
          };
        }
      });
    }
  }
};

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var consolidate$2 = {exports: {}};

(function (module, exports) {
	/*
	 * Engines which do not support caching of their file contents
	 * should use the `read()` function defined in consolidate.js
	 * On top of this, when an engine compiles to a `Function`,
	 * these functions should either be cached within consolidate.js
	 * or the engine itself via `options.cache`. This will allow
	 * users and frameworks to pass `options.cache = true` for
	 * `NODE_ENV=production`, however edit the file(s) without
	 * re-loading the application in development.
	 */

	/**
	 * Module dependencies.
	 */

	var fs = require$$0;
	var path = path$3;
	var util = require$$2;

	var join = path.join;
	var resolve = path.resolve;
	var extname = path.extname;
	var dirname = path.dirname;
	var isAbsolute = path.isAbsolute;

	var readCache = {};

	/**
	 * Require cache.
	 */

	var cacheStore = {};

	/**
	 * Require cache.
	 */

	var requires = {};

	/**
	 * Clear the cache.
	 *
	 * @api public
	 */

	exports.clearCache = function() {
	  readCache = {};
	  cacheStore = {};
	};

	/**
	 * Conditionally cache `compiled` template based
	 * on the `options` filename and `.cache` boolean.
	 *
	 * @param {Object} options
	 * @param {Function} compiled
	 * @return {Function}
	 * @api private
	 */

	function cache(options, compiled) {
	  // cachable
	  if (compiled && options.filename && options.cache) {
	    delete readCache[options.filename];
	    cacheStore[options.filename] = compiled;
	    return compiled;
	  }

	  // check cache
	  if (options.filename && options.cache) {
	    return cacheStore[options.filename];
	  }

	  return compiled;
	}

	/**
	 * Read `path` with `options` with
	 * callback `(err, str)`. When `options.cache`
	 * is true the template string will be cached.
	 *
	 * @param {String} options
	 * @param {Function} cb
	 * @api private
	 */

	function read(path, options, cb) {
	  var str = readCache[path];
	  var cached = options.cache && str && typeof str === 'string';

	  // cached (only if cached is a string and not a compiled template function)
	  if (cached) return cb(null, str);

	  // read
	  fs.readFile(path, 'utf8', function(err, str) {
	    if (err) return cb(err);
	    // remove extraneous utf8 BOM marker
	    str = str.replace(/^\uFEFF/, '');
	    if (options.cache) readCache[path] = str;
	    cb(null, str);
	  });
	}

	/**
	 * Read `path` with `options` with
	 * callback `(err, str)`. When `options.cache`
	 * is true the partial string will be cached.
	 *
	 * @param {String} options
	 * @param {Function} fn
	 * @api private
	 */

	function readPartials(path, options, cb) {
	  if (!options.partials) return cb();
	  var keys = Object.keys(options.partials);
	  var partials = {};

	  function next(index) {
	    if (index === keys.length) return cb(null, partials);
	    var key = keys[index];
	    var partialPath = options.partials[key];

	    if (partialPath === undefined || partialPath === null || partialPath === false) {
	      return next(++index);
	    }

	    var file;
	    if (isAbsolute(partialPath)) {
	      if (extname(partialPath) !== '') {
	        file = partialPath;
	      } else {
	        file = join(partialPath + extname(path));
	      }
	    } else {
	      file = join(dirname(path), partialPath + extname(path));
	    }

	    read(file, options, function(err, str) {
	      if (err) return cb(err);
	      partials[key] = str;
	      next(++index);
	    });
	  }

	  next(0);
	}

	/**
	 * promisify
	 */
	function promisify(cb, fn) {
	  return new Promise(function(resolve, reject) {
	    cb = cb || function(err, html) {
	      if (err) {
	        return reject(err);
	      }
	      resolve(html);
	    };
	    fn(cb);
	  });
	}

	/**
	 * fromStringRenderer
	 */

	function fromStringRenderer(name) {
	  return function(path, options, cb) {
	    options.filename = path;

	    return promisify(cb, function(cb) {
	      readPartials(path, options, function(err, partials) {
	        var extend = (requires.extend || (requires.extend = require$$2._extend));
	        var opts = extend({}, options);
	        opts.partials = partials;
	        if (err) return cb(err);
	        if (cache(opts)) {
	          exports[name].render('', opts, cb);
	        } else {
	          read(path, opts, function(err, str) {
	            if (err) return cb(err);
	            exports[name].render(str, opts, cb);
	          });
	        }
	      });
	    });
	  };
	}

	/**
	 * velocity support.
	 */

	exports.velocityjs = fromStringRenderer('velocityjs');

	/**
	 * velocity string support.
	 */

	exports.velocityjs.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.velocityjs || (requires.velocityjs = require('velocityjs'));
	    try {
	      options.locals = options;
	      cb(null, engine.render(str, options).trimLeft());
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Liquid support.
	 */

	exports.liquid = fromStringRenderer('liquid');

	/**
	 * Liquid string support.
	 */

	/**
	 * Note that in order to get filters and custom tags we've had to push
	 * all user-defined locals down into @locals. However, just to make things
	 * backwards-compatible, any property of `options` that is left after
	 * processing and removing `locals`, `meta`, `filters`, `customTags` and
	 * `includeDir` will also become a local.
	 */

	function _renderTinyliquid(engine, str, options, cb) {
	  var context = engine.newContext();
	  var k;

	  /**
	   * Note that there's a bug in the library that doesn't allow us to pass
	   * the locals to newContext(), hence looping through the keys:
	   */

	  if (options.locals) {
	    for (k in options.locals) {
	      context.setLocals(k, options.locals[k]);
	    }
	    delete options.locals;
	  }

	  if (options.meta) {
	    context.setLocals('page', options.meta);
	    delete options.meta;
	  }

	  /**
	   * Add any defined filters:
	   */

	  if (options.filters) {
	    for (k in options.filters) {
	      context.setFilter(k, options.filters[k]);
	    }
	    delete options.filters;
	  }

	  /**
	   * Set up a callback for the include directory:
	   */

	  var includeDir = options.includeDir || process.cwd();

	  context.onInclude(function(name, callback) {
	    var extname = path.extname(name) ? '' : '.liquid';
	    var filename = path.resolve(includeDir, name + extname);

	    fs.readFile(filename, {encoding: 'utf8'}, function(err, data) {
	      if (err) return callback(err);
	      callback(null, engine.parse(data));
	    });
	  });
	  delete options.includeDir;

	  /**
	   * The custom tag functions need to have their results pushed back
	   * through the parser, so set up a shim before calling the provided
	   * callback:
	   */

	  var compileOptions = {
	    customTags: {}
	  };

	  if (options.customTags) {
	    var tagFunctions = options.customTags;

	    for (k in options.customTags) {
	      /*Tell jshint there's no problem with having this function in the loop */
	      /*jshint -W083 */
	      compileOptions.customTags[k] = function(context, name, body) {
	        var tpl = tagFunctions[name](body.trim());
	        context.astStack.push(engine.parse(tpl));
	      };
	      /*jshint +W083 */
	    }
	    delete options.customTags;
	  }

	  /**
	   * Now anything left in `options` becomes a local:
	   */

	  for (k in options) {
	    context.setLocals(k, options[k]);
	  }

	  /**
	   * Finally, execute the template:
	   */

	  var tmpl = cache(context) || cache(context, engine.compile(str, compileOptions));
	  tmpl(context, cb);
	}

	exports.liquid.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.liquid;
	    var Liquid;

	    try {
	      // set up tinyliquid engine
	      engine = requires.liquid = require('tinyliquid');

	      // use tinyliquid engine
	      _renderTinyliquid(engine, str, options, cb);

	      return;

	    } catch (err) {

	      // set up liquid-node engine
	      try {
	        Liquid = requires.liquid = require('liquid-node');
	        engine = new Liquid.Engine();
	      } catch (err) {
	        throw err;
	      }

	    }

	    // use liquid-node engine
	    try {
	      var locals = options.locals || {};

	      if (options.meta) {
	        locals.pages = options.meta;
	        delete options.meta;
	      }

	      /**
	       * Add any defined filters:
	       */

	      if (options.filters) {
	        engine.registerFilters(options.filters);
	        delete options.filters;
	      }

	      /**
	       * Set up a callback for the include directory:
	       */

	      var includeDir = options.includeDir || process.cwd();
	      engine.fileSystem = new Liquid.LocalFileSystem(includeDir, 'liquid');
	      delete options.includeDir;

	      /**
	       * The custom tag functions need to have their results pushed back
	       * through the parser, so set up a shim before calling the provided
	       * callback:
	       */

	      if (options.customTags) {
	        var tagFunctions = options.customTags;

	        for (k in options.customTags) {
	          engine.registerTag(k, tagFunctions[k]);
	        }
	        delete options.customTags;
	      }

	      /**
	       * Now anything left in `options` becomes a local:
	       */

	      for (var k in options) {
	        locals[k] = options[k];
	      }

	      /**
	       * Finally, execute the template:
	       */

	      return engine
	        .parseAndRender(str, locals)
	        .nodeify(function(err, result) {
	          if (err) {
	            throw new Error(err);
	          } else {
	            return cb(null, result);
	          }
	        });

	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Jade support.
	 */

	exports.jade = function(path, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.jade;
	    if (!engine) {
	      try {
	        engine = requires.jade = require('jade');
	      } catch (err) {
	        try {
	          engine = requires.jade = require('then-jade');
	        } catch (otherError) {
	          throw err;
	        }
	      }
	    }

	    try {
	      var tmpl = cache(options) || cache(options, engine.compileFile(path, options));
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Jade string support.
	 */

	exports.jade.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.jade;
	    if (!engine) {
	      try {
	        engine = requires.jade = require('jade');
	      } catch (err) {
	        try {
	          engine = requires.jade = require('then-jade');
	        } catch (otherError) {
	          throw err;
	        }
	      }
	    }

	    try {
	      var tmpl = cache(options) || cache(options, engine.compile(str, options));
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Dust support.
	 */

	exports.dust = fromStringRenderer('dust');

	/**
	 * Dust string support.
	 */

	exports.dust.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.dust;
	    if (!engine) {
	      try {
	        engine = requires.dust = require('dust');
	      } catch (err) {
	        try {
	          engine = requires.dust = require('dustjs-helpers');
	        } catch (err) {
	          engine = requires.dust = require('dustjs-linkedin');
	        }
	      }
	    }

	    var ext = 'dust';
	    var views = '.';

	    if (options) {
	      if (options.ext) ext = options.ext;
	      if (options.views) views = options.views;
	      if (options.settings && options.settings.views) views = options.settings.views;
	    }
	    if (!options || (options && !options.cache)) engine.cache = {};

	    engine.onLoad = function(path, callback) {
	      if (extname(path) === '') path += '.' + ext;
	      if (path[0] !== '/') path = views + '/' + path;
	      read(path, options, callback);
	    };

	    try {
	      var templateName;
	      if (options.filename) {
	        templateName = options.filename.replace(new RegExp('^' + views + '/'), '').replace(new RegExp('\\.' + ext), '');
	      }

	      var tmpl = cache(options) || cache(options, engine.compileFn(str, templateName));
	      tmpl(options, cb);
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Swig support.
	 */

	exports.swig = fromStringRenderer('swig');

	/**
	 * Swig string support.
	 */

	exports.swig.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.swig;
	    if (!engine) {
	      try {
	        engine = requires.swig = require('swig');
	      } catch (err) {
	        try {
	          engine = requires.swig = require('swig-templates');
	        } catch (otherError) {
	          throw err;
	        }
	      }
	    }

	    try {
	      if (options.cache === true) options.cache = 'memory';
	      engine.setDefaults({ cache: options.cache });
	      var tmpl = cache(options) || cache(options, engine.compile(str, options));
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Razor support.
	 */

	exports.razor = function(path, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.razor;
	    if (!engine) {
	      try {
	        engine = requires.razor = require('razor-tmpl');

	      } catch (err) {

	        throw err;

	      }
	    }
	    try {

	      var tmpl = cache(options) || cache(options, (locals) => {
	        console.log('Rendering razor file', path);
	        return engine.renderFileSync(path, locals);
	      });
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * razor string support.
	 */

	exports.razor.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {

	    try {
	      var engine = requires.razor = require('razor-tmpl');
	    } catch (err) {
	      throw err;
	    }

	    try {
	      var tf = engine.compile(str);
	      var tmpl = cache(options) || cache(options, tf);
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Atpl support.
	 */

	exports.atpl = fromStringRenderer('atpl');

	/**
	 * Atpl string support.
	 */

	exports.atpl.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.atpl || (requires.atpl = require('atpl'));
	    try {
	      var tmpl = cache(options) || cache(options, engine.compile(str, options));
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Liquor support,
	 */

	exports.liquor = fromStringRenderer('liquor');

	/**
	 * Liquor string support.
	 */

	exports.liquor.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.liquor || (requires.liquor = require('liquor'));
	    try {
	      var tmpl = cache(options) || cache(options, engine.compile(str, options));
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Twig support.
	 */

	exports.twig = fromStringRenderer('twig');

	/**
	 * Twig string support.
	 */

	exports.twig.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.twig || (requires.twig = require('twig').twig);
	    var templateData = {
	      data: str,
	      allowInlineIncludes: options.allowInlineIncludes,
	      namespaces: options.namespaces,
	      path: options.path
	    };
	    try {
	      var tmpl = cache(templateData) || cache(templateData, engine(templateData));
	      cb(null, tmpl.render(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * EJS support.
	 */

	exports.ejs = fromStringRenderer('ejs');

	/**
	 * EJS string support.
	 */

	exports.ejs.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.ejs || (requires.ejs = require('ejs'));
	    try {
	      var tmpl = cache(options) || cache(options, engine.compile(str, options));
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Eco support.
	 */

	exports.eco = fromStringRenderer('eco');

	/**
	 * Eco string support.
	 */

	exports.eco.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.eco || (requires.eco = require('eco'));
	    try {
	      cb(null, engine.render(str, options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Jazz support.
	 */

	exports.jazz = fromStringRenderer('jazz');

	/**
	 * Jazz string support.
	 */

	exports.jazz.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.jazz || (requires.jazz = require('jazz'));
	    try {
	      var tmpl = cache(options) || cache(options, engine.compile(str, options));
	      tmpl.eval(options, function(str) {
	        cb(null, str);
	      });
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * JQTPL support.
	 */

	exports.jqtpl = fromStringRenderer('jqtpl');

	/**
	 * JQTPL string support.
	 */

	exports.jqtpl.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.jqtpl || (requires.jqtpl = require('jqtpl'));
	    try {
	      engine.template(str, str);
	      cb(null, engine.tmpl(str, options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Haml support.
	 */

	exports.haml = fromStringRenderer('haml');

	/**
	 * Haml string support.
	 */

	exports.haml.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.haml || (requires.haml = require('hamljs'));
	    try {
	      options.locals = options;
	      cb(null, engine.render(str, options).trimLeft());
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Hamlet support.
	 */

	exports.hamlet = fromStringRenderer('hamlet');

	/**
	 * Hamlet string support.
	 */

	exports.hamlet.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.hamlet || (requires.hamlet = require('hamlet'));
	    try {
	      options.locals = options;
	      cb(null, engine.render(str, options).trimLeft());
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Whiskers support.
	 */

	exports.whiskers = function(path, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.whiskers || (requires.whiskers = require('whiskers'));
	    engine.__express(path, options, cb);
	  });
	};

	/**
	 * Whiskers string support.
	 */

	exports.whiskers.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.whiskers || (requires.whiskers = require('whiskers'));
	    try {
	      cb(null, engine.render(str, options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Coffee-HAML support.
	 */

	exports['haml-coffee'] = fromStringRenderer('haml-coffee');

	/**
	 * Coffee-HAML string support.
	 */

	exports['haml-coffee'].render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires['haml-coffee'] || (requires['haml-coffee'] = require('haml-coffee'));
	    try {
	      var tmpl = cache(options) || cache(options, engine.compile(str, options));
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Hogan support.
	 */

	exports.hogan = fromStringRenderer('hogan');

	/**
	 * Hogan string support.
	 */

	exports.hogan.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.hogan || (requires.hogan = require('hogan.js'));
	    try {
	      var tmpl = cache(options) || cache(options, engine.compile(str, options));
	      cb(null, tmpl.render(options, options.partials));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * templayed.js support.
	 */

	exports.templayed = fromStringRenderer('templayed');

	/**
	 * templayed.js string support.
	 */

	exports.templayed.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.templayed || (requires.templayed = require('templayed'));
	    try {
	      var tmpl = cache(options) || cache(options, engine(str));
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Handlebars support.
	 */

	exports.handlebars = fromStringRenderer('handlebars');

	/**
	 * Handlebars string support.
	 */

	exports.handlebars.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.handlebars || (requires.handlebars = require('handlebars'));
	    try {
	      for (var partial in options.partials) {
	        engine.registerPartial(partial, options.partials[partial]);
	      }
	      for (var helper in options.helpers) {
	        engine.registerHelper(helper, options.helpers[helper]);
	      }
	      var tmpl = cache(options) || cache(options, engine.compile(str, options));
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Underscore support.
	 */

	exports.underscore = fromStringRenderer('underscore');

	/**
	 * Underscore string support.
	 */

	exports.underscore.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.underscore || (requires.underscore = require('underscore'));
	    try {
	      const partials = {};
	      for (var partial in options.partials) {
	        partials[partial] = engine.template(options.partials[partial]);
	      }
	      options.partials = partials;
	      var tmpl = cache(options) || cache(options, engine.template(str, null, options));
	      cb(null, tmpl(options).replace(/\n$/, ''));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Lodash support.
	 */

	exports.lodash = fromStringRenderer('lodash');

	/**
	 * Lodash string support.
	 */

	exports.lodash.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.lodash || (requires.lodash = require('lodash'));
	    try {
	      var tmpl = cache(options) || cache(options, engine.template(str, options));
	      cb(null, tmpl(options).replace(/\n$/, ''));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Pug support. (formerly Jade)
	 */

	exports.pug = function(path, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.pug;
	    if (!engine) {
	      try {
	        engine = requires.pug = require('pug');
	      } catch (err) {
	        try {
	          engine = requires.pug = require('then-pug');
	        } catch (otherError) {
	          throw err;
	        }
	      }
	    }

	    try {
	      var tmpl = cache(options) || cache(options, engine.compileFile(path, options));
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Pug string support.
	 */

	exports.pug.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.pug;
	    if (!engine) {
	      try {
	        engine = requires.pug = require('pug');
	      } catch (err) {
	        try {
	          engine = requires.pug = require('then-pug');
	        } catch (otherError) {
	          throw err;
	        }
	      }
	    }

	    try {
	      var tmpl = cache(options) || cache(options, engine.compile(str, options));
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * QEJS support.
	 */

	exports.qejs = fromStringRenderer('qejs');

	/**
	 * QEJS string support.
	 */

	exports.qejs.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    try {
	      var engine = requires.qejs || (requires.qejs = require('qejs'));
	      engine.render(str, options).then(function(result) {
	        cb(null, result);
	      }, function(err) {
	        cb(err);
	      }).done();
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Walrus support.
	 */

	exports.walrus = fromStringRenderer('walrus');

	/**
	 * Walrus string support.
	 */

	exports.walrus.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.walrus || (requires.walrus = require('walrus'));
	    try {
	      var tmpl = cache(options) || cache(options, engine.parse(str));
	      cb(null, tmpl.compile(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Mustache support.
	 */

	exports.mustache = fromStringRenderer('mustache');

	/**
	 * Mustache string support.
	 */

	exports.mustache.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.mustache || (requires.mustache = require('mustache'));
	    try {
	      cb(null, engine.render(str, options, options.partials));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Just support.
	 */

	exports.just = function(path, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.just;
	    if (!engine) {
	      var JUST = require('just');
	      engine = requires.just = new JUST();
	    }
	    engine.configure({ useCache: options.cache });
	    engine.render(path, options, cb);
	  });
	};

	/**
	 * Just string support.
	 */

	exports.just.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var JUST = require('just');
	    var engine = new JUST({ root: { page: str }});
	    engine.render('page', options, cb);
	  });
	};

	/**
	 * ECT support.
	 */

	exports.ect = function(path, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.ect;
	    if (!engine) {
	      var ECT = require('ect');
	      engine = requires.ect = new ECT(options);
	    }
	    engine.configure({ cache: options.cache });
	    engine.render(path, options, cb);
	  });
	};

	/**
	 * ECT string support.
	 */

	exports.ect.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var ECT = require('ect');
	    var engine = new ECT({ root: { page: str }});
	    engine.render('page', options, cb);
	  });
	};

	/**
	 * mote support.
	 */

	exports.mote = fromStringRenderer('mote');

	/**
	 * mote string support.
	 */

	exports.mote.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.mote || (requires.mote = require('mote'));
	    try {
	      var tmpl = cache(options) || cache(options, engine.compile(str));
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Toffee support.
	 */

	exports.toffee = function(path, options, cb) {
	  return promisify(cb, function(cb) {
	    var toffee = requires.toffee || (requires.toffee = require('toffee'));
	    toffee.__consolidate_engine_render(path, options, cb);
	  });
	};

	/**
	 * Toffee string support.
	 */

	exports.toffee.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.toffee || (requires.toffee = require('toffee'));
	    try {
	      engine.str_render(str, options, cb);
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * doT support.
	 */

	exports.dot = fromStringRenderer('dot');

	/**
	 * doT string support.
	 */

	exports.dot.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.dot || (requires.dot = require('dot'));
	    var extend = (requires.extend || (requires.extend = require$$2._extend));
	    try {
	      var settings = {};
	      settings = extend(settings, engine.templateSettings);
	      settings = extend(settings, options ? options.dot : {});
	      var tmpl = cache(options) || cache(options, engine.template(str, settings, options));
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * bracket support.
	 */

	exports.bracket = fromStringRenderer('bracket');

	/**
	 * bracket string support.
	 */

	exports.bracket.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.bracket || (requires.bracket = require('bracket-template'));
	    try {
	      var tmpl = cache(options) || cache(options, engine.default.compile(str, options));
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Ractive support.
	 */

	exports.ractive = fromStringRenderer('ractive');

	/**
	 * Ractive string support.
	 */

	exports.ractive.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var Engine = requires.ractive || (requires.ractive = require('ractive'));

	    var template = cache(options) || cache(options, Engine.parse(str));
	    options.template = template;

	    if (options.data === null || options.data === undefined) {
	      var extend = (requires.extend || (requires.extend = require$$2._extend));

	      // Shallow clone the options object
	      options.data = extend({}, options);

	      // Remove consolidate-specific properties from the clone
	      var i;
	      var length;
	      var properties = ['template', 'filename', 'cache', 'partials'];
	      for (i = 0, length = properties.length; i < length; i++) {
	        var property = properties[i];
	        delete options.data[property];
	      }
	    }

	    try {
	      cb(null, new Engine(options).toHTML());
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Nunjucks support.
	 */

	exports.nunjucks = fromStringRenderer('nunjucks');

	/**
	 * Nunjucks string support.
	 */

	exports.nunjucks.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {

	    try {

	      var engine = options.nunjucksEnv || requires.nunjucks || (requires.nunjucks = require('nunjucks'));

	      var env = engine;

	      // deprecated fallback support for express
	      // <https://github.com/tj/consolidate.js/pull/152>
	      // <https://github.com/tj/consolidate.js/pull/224>
	      if (options.settings && options.settings.views) {
	        env = engine.configure(options.settings.views);
	      } else if (options.nunjucks && options.nunjucks.configure) {
	        env = engine.configure.apply(engine, options.nunjucks.configure);
	      }

	      //
	      // because `renderString` does not initiate loaders
	      // we must manually create a loader for it based off
	      // either `options.settings.views` or `options.nunjucks` or `options.nunjucks.root`
	      //
	      // <https://github.com/mozilla/nunjucks/issues/730>
	      // <https://github.com/crocodilejs/node-email-templates/issues/182>
	      //

	      // so instead we simply check if we passed a custom loader
	      // otherwise we create a simple file based loader
	      if (options.loader) {
	        env = new engine.Environment(options.loader);
	      } else if (options.settings && options.settings.views) {
	        env = new engine.Environment(
	          new engine.FileSystemLoader(options.settings.views)
	        );
	      } else if (options.nunjucks && options.nunjucks.loader) {
	        if (typeof options.nunjucks.loader === 'string') {
	          env = new engine.Environment(new engine.FileSystemLoader(options.nunjucks.loader));
	        } else {
	          env = new engine.Environment(
	            new engine.FileSystemLoader(
	              options.nunjucks.loader[0],
	              options.nunjucks.loader[1]
	            )
	          );
	        }
	      }

	      env.renderString(str, options, cb);
	    } catch (err) {
	      throw cb(err);
	    }
	  });
	};

	/**
	 * HTMLing support.
	 */

	exports.htmling = fromStringRenderer('htmling');

	/**
	 * HTMLing string support.
	 */

	exports.htmling.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.htmling || (requires.htmling = require('htmling'));
	    try {
	      var tmpl = cache(options) || cache(options, engine.string(str));
	      cb(null, tmpl.render(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 *  Rendering function
	 */
	function requireReact(module, filename) {
	  var babel = requires.babel || (requires.babel = require('babel-core'));

	  var compiled = babel.transformFileSync(filename, { presets: [ 'react' ] }).code;

	  return module._compile(compiled, filename);
	}

	exports.requireReact = requireReact;

	/**
	 *  Converting a string into a node module.
	 */
	function requireReactString(src, filename) {
	  var babel = requires.babel || (requires.babel = require('babel-core'));

	  if (!filename) filename = '';
	  var m = new module.constructor();
	  filename = filename || '';

	  // Compile Using React
	  var compiled = babel.transform(src, { presets: [ 'react' ] }).code;

	  // Compile as a module
	  m.paths = module.paths;
	  m._compile(compiled, filename);

	  return m.exports;
	}

	/**
	 * A naive helper to replace {{tags}} with options.tags content
	 */
	function reactBaseTmpl(data, options) {

	  var exp;
	  var regex;

	  // Iterates through the keys in file object
	  // and interpolate / replace {{key}} with it's value
	  for (var k in options) {
	    if (options.hasOwnProperty(k)) {
	      exp = '{{' + k + '}}';
	      regex = new RegExp(exp, 'g');
	      if (data.match(regex)) {
	        data = data.replace(regex, options[k]);
	      }
	    }
	  }

	  return data;
	}

	/**
	* Plates Support.
	*/

	exports.plates = fromStringRenderer('plates');

	/**
	* Plates string support.
	*/

	exports.plates.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.plates || (requires.plates = require('plates'));
	    var map = options.map || undefined;
	    try {
	      var tmpl = engine.bind(str, options, map);
	      cb(null, tmpl);
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 *  The main render parser for React bsaed templates
	 */
	function reactRenderer(type) {

	  if (commonjsRequire.extensions) {

	    // Ensure JSX is transformed on require
	    if (!commonjsRequire.extensions['.jsx']) {
	      commonjsRequire.extensions['.jsx'] = requireReact;
	    }

	    // Supporting .react extension as well as test cases
	    // Using .react extension is not recommended.
	    if (!commonjsRequire.extensions['.react']) {
	      commonjsRequire.extensions['.react'] = requireReact;
	    }

	  }

	  // Return rendering fx
	  return function(str, options, cb) {
	    return promisify(cb, function(cb) {
	      // React Import
	      var ReactDOM = requires.ReactDOM || (requires.ReactDOM = require('react-dom/server'));
	      var react = requires.react || (requires.react = require('react'));

	      // Assign HTML Base
	      var base = options.base;
	      delete options.base;

	      var enableCache = options.cache;
	      delete options.cache;

	      var isNonStatic = options.isNonStatic;
	      delete options.isNonStatic;

	      // Start Conversion
	      try {

	        var Code;
	        var Factory;

	        var baseStr;
	        var content;
	        var parsed;

	        if (!cache(options)) {
	          // Parsing
	          if (type === 'path') {
	            var path = resolve(str);
	            delete require.cache[path];
	            Code = commonjsRequire(path);
	          } else {
	            Code = requireReactString(str);
	          }
	          Factory = cache(options, react.createFactory(Code));

	        } else {
	          Factory = cache(options);
	        }

	        parsed = new Factory(options);
	        content = (isNonStatic) ? ReactDOM.renderToString(parsed) : ReactDOM.renderToStaticMarkup(parsed);

	        if (base) {
	          baseStr = readCache[str] || fs.readFileSync(resolve(base), 'utf8');

	          if (enableCache) {
	            readCache[str] = baseStr;
	          }

	          options.content = content;
	          content = reactBaseTmpl(baseStr, options);
	        }

	        cb(null, content);

	      } catch (err) {
	        cb(err);
	      }
	    });
	  };
	}

	/**
	 * React JS Support
	 */
	exports.react = reactRenderer('path');

	/**
	 * React JS string support.
	 */
	exports.react.render = reactRenderer('string');

	/**
	 * ARC-templates support.
	 */

	exports['arc-templates'] = fromStringRenderer('arc-templates');

	/**
	 * ARC-templates string support.
	 */

	exports['arc-templates'].render = function(str, options, cb) {
	  var readFileWithOptions = util.promisify(read);
	  var consolidateFileSystem = {};
	  consolidateFileSystem.readFile = function(path) {
	    return readFileWithOptions(path, options);
	  };

	  return promisify(cb, function(cb) {
	    try {
	      var engine = requires['arc-templates'];
	      if (!engine) {
	        var Engine = require('arc-templates/dist/es5');
	        engine = requires['arc-templates'] = new Engine({ filesystem: consolidateFileSystem });
	      }

	      var compiler = cache(options) || cache(options, engine.compileString(str, options.filename));
	      compiler.then(function(func) { return func(options); })
	        .then(function(result) { cb(null, result.content); })
	        .catch(cb);
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Vash support
	 */
	exports.vash = fromStringRenderer('vash');

	/**
	 * Vash string support
	 */
	exports.vash.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.vash || (requires.vash = require('vash'));

	    try {
	      // helper system : https://github.com/kirbysayshi/vash#helper-system
	      if (options.helpers) {
	        for (var key in options.helpers) {
	          if (!options.helpers.hasOwnProperty(key) || typeof options.helpers[key] !== 'function') {
	            continue;
	          }
	          engine.helpers[key] = options.helpers[key];
	        }
	      }

	      var tmpl = cache(options) || cache(options, engine.compile(str, options));
	      tmpl(options, function sealLayout(err, ctx) {
	        if (err) cb(err);
	        ctx.finishLayout();
	        cb(null, ctx.toString().replace(/\n$/, ''));
	      });
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Slm support.
	 */

	exports.slm = fromStringRenderer('slm');

	/**
	 * Slm string support.
	 */

	exports.slm.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.slm || (requires.slm = require('slm'));

	    try {
	      var tmpl = cache(options) || cache(options, engine.compile(str, options));
	      cb(null, tmpl(options));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Marko support.
	 */

	exports.marko = function(path, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.marko || (requires.marko = require('marko'));
	    options.writeToDisk = !!options.cache;

	    try {
	      var tmpl = cache(options) || cache(options, engine.load(path, options));
	      tmpl.renderToString(options, cb);
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Marko string support.
	 */

	exports.marko.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.marko || (requires.marko = require('marko'));
	    options.writeToDisk = !!options.cache;
	    options.filename = options.filename || 'string.marko';

	    try {
	      var tmpl = cache(options) || cache(options, engine.load(options.filename, str, options));
	      tmpl.renderToString(options, cb);
	    } catch (err) {
	      cb(err);
	    }
	  });
	};

	/**
	 * Teacup support.
	 */
	exports.teacup = function(path, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.teacup || (requires.teacup = require('teacup/lib/express'));
	    commonjsRequire.extensions['.teacup'] = commonjsRequire.extensions['.coffee'];
	    if (path[0] !== '/') {
	      path = join(process.cwd(), path);
	    }
	    if (!options.cache) {
	      var callback = cb;
	      cb = function() {
	        delete require.cache[path];
	        callback.apply(this, arguments);
	      };
	    }
	    engine.renderFile(path, options, cb);
	  });
	};

	/**
	 * Teacup string support.
	 */
	exports.teacup.render = function(str, options, cb) {
	  var coffee = require('coffee-script');
	  var vm = require('vm');
	  var sandbox = {
	    module: {exports: {}},
	    require: commonjsRequire
	  };
	  return promisify(cb, function(cb) {
	    vm.runInNewContext(coffee.compile(str), sandbox);
	    var tmpl = sandbox.module.exports;
	    cb(null, tmpl(options));
	  });
	};

	/**
	 * Squirrelly support.
	 */

	exports.squirrelly = fromStringRenderer('squirrelly');

	/**
	 * Squirrelly string support.
	 */

	exports.squirrelly.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.squirrelly || (requires.squirrelly = require('squirrelly'));
	    try {
	      for (var partial in options.partials) {
	        engine.definePartial(partial, options.partials[partial]);
	      }
	      for (var helper in options.helpers) {
	        engine.defineHelper(helper, options.helpers[helper]);
	      }
	      var tmpl = cache(options) || cache(options, engine.Compile(str, options));
	      cb(null, tmpl(options, engine));
	    } catch (err) {
	      cb(err);
	    }
	  });
	};
	/**
	 * Twing support.
	 */

	exports.twing = fromStringRenderer('twing');

	/**
	 * Twing string support.
	 */ 

	exports.twing.render = function(str, options, cb) {
	  return promisify(cb, function(cb) {
	    var engine = requires.twing || (requires.twing = require('twing'));
	    try {
	      new engine.TwingEnvironment(new engine.TwingLoaderNull()).createTemplate(str).then((twingTemplate) => {
	        twingTemplate.render(options).then((rendTmpl) => {
	          var tmpl = cache(options) || cache(options, rendTmpl);
	          cb(null, tmpl);
	        });
	      });
	    } catch (err) {
	      cb(err);
	    }
	  });
	};
	/**
	 * expose the instance of the engine
	 */
	exports.requires = requires; 
} (consolidate$2, consolidate$2.exports));

var consolidateExports = consolidate$2.exports;

var consolidate = consolidateExports;

var consolidate$1 = /*@__PURE__*/getDefaultExportFromCjs(consolidate);

const hasWarned = {};
function warnOnce(msg) {
  const isNodeProd = typeof process !== "undefined" && process.env.NODE_ENV === "production";
  if (!isNodeProd && true && !hasWarned[msg]) {
    hasWarned[msg] = true;
    warn(msg);
  }
}
function warn(msg) {
  console.warn(
    `\x1B[1m\x1B[33m[@vue/compiler-sfc]\x1B[0m\x1B[33m ${msg}\x1B[0m
`
  );
}

function preprocess$1({ source, filename, preprocessOptions }, preprocessor) {
  let res = "";
  let err = null;
  preprocessor.render(
    source,
    { filename, ...preprocessOptions },
    (_err, _res) => {
      if (_err)
        err = _err;
      res = _res;
    }
  );
  if (err)
    throw err;
  return res;
}
function compileTemplate(options) {
  const { preprocessLang, preprocessCustomRequire } = options;
  const preprocessor = preprocessLang ? preprocessCustomRequire ? preprocessCustomRequire(preprocessLang) : consolidate$1[preprocessLang] : false;
  if (preprocessor) {
    try {
      return doCompileTemplate({
        ...options,
        source: preprocess$1(options, preprocessor),
        ast: void 0
        // invalidate AST if template goes through preprocessor
      });
    } catch (e) {
      return {
        code: `export default function render() {}`,
        source: options.source,
        tips: [],
        errors: [e]
      };
    }
  } else if (preprocessLang) {
    return {
      code: `export default function render() {}`,
      source: options.source,
      tips: [
        `Component ${options.filename} uses lang ${preprocessLang} for template. Please install the language preprocessor.`
      ],
      errors: [
        `Component ${options.filename} uses lang ${preprocessLang} for template, however it is not installed.`
      ]
    };
  } else {
    return doCompileTemplate(options);
  }
}
function doCompileTemplate({
  filename,
  id,
  scoped,
  slotted,
  inMap,
  source,
  ast: inAST,
  ssr = false,
  ssrCssVars,
  isProd = false,
  compiler,
  compilerOptions = {},
  transformAssetUrls
}) {
  const errors = [];
  const warnings = [];
  let nodeTransforms = [];
  if (shared.isObject(transformAssetUrls)) {
    const assetOptions = normalizeOptions(transformAssetUrls);
    nodeTransforms = [
      createAssetUrlTransformWithOptions(assetOptions),
      createSrcsetTransformWithOptions(assetOptions)
    ];
  } else if (transformAssetUrls !== false) {
    nodeTransforms = [transformAssetUrl, transformSrcset];
  }
  if (ssr && !ssrCssVars) {
    warnOnce(
      `compileTemplate is called with \`ssr: true\` but no corresponding \`cssVars\` option.\`.`
    );
  }
  if (!id) {
    warnOnce(`compileTemplate now requires the \`id\` option.\`.`);
    id = "";
  }
  const shortId = id.replace(/^data-v-/, "");
  const longId = `data-v-${shortId}`;
  const defaultCompiler = ssr ? CompilerSSR__namespace : CompilerDOM__namespace;
  compiler = compiler || defaultCompiler;
  if (compiler !== defaultCompiler) {
    inAST = void 0;
  }
  if (inAST == null ? void 0 : inAST.transformed) {
    const newAST = (ssr ? CompilerDOM__namespace : compiler).parse(inAST.source, {
      prefixIdentifiers: true,
      ...compilerOptions,
      parseMode: "sfc",
      onError: (e) => errors.push(e)
    });
    const template = newAST.children.find(
      (node) => node.type === 1 && node.tag === "template"
    );
    inAST = compilerCore.createRoot(template.children, inAST.source);
  }
  let { code, ast, preamble, map } = compiler.compile(inAST || source, {
    mode: "module",
    prefixIdentifiers: true,
    hoistStatic: true,
    cacheHandlers: true,
    ssrCssVars: ssr && ssrCssVars && ssrCssVars.length ? genCssVarsFromList(ssrCssVars, shortId, isProd, true) : "",
    scopeId: scoped ? longId : void 0,
    slotted,
    sourceMap: true,
    ...compilerOptions,
    hmr: !isProd,
    nodeTransforms: nodeTransforms.concat(compilerOptions.nodeTransforms || []),
    filename,
    onError: (e) => errors.push(e),
    onWarn: (w) => warnings.push(w)
  });
  if (inMap && !inAST) {
    if (map) {
      map = mapLines(inMap, map);
    }
    if (errors.length) {
      patchErrors(errors, source, inMap);
    }
  }
  const tips = warnings.map((w) => {
    let msg = w.message;
    if (w.loc) {
      msg += `
${shared.generateCodeFrame(
        (inAST == null ? void 0 : inAST.source) || source,
        w.loc.start.offset,
        w.loc.end.offset
      )}`;
    }
    return msg;
  });
  return { code, ast, preamble, source, errors, tips, map };
}
function mapLines(oldMap, newMap) {
  if (!oldMap)
    return newMap;
  if (!newMap)
    return oldMap;
  const oldMapConsumer = new sourceMapJs.SourceMapConsumer(oldMap);
  const newMapConsumer = new sourceMapJs.SourceMapConsumer(newMap);
  const mergedMapGenerator = new sourceMapJs.SourceMapGenerator();
  newMapConsumer.eachMapping((m) => {
    if (m.originalLine == null) {
      return;
    }
    const origPosInOldMap = oldMapConsumer.originalPositionFor({
      line: m.originalLine,
      column: m.originalColumn
    });
    if (origPosInOldMap.source == null) {
      return;
    }
    mergedMapGenerator.addMapping({
      generated: {
        line: m.generatedLine,
        column: m.generatedColumn
      },
      original: {
        line: origPosInOldMap.line,
        // map line
        // use current column, since the oldMap produced by @vue/compiler-sfc
        // does not
        column: m.originalColumn
      },
      source: origPosInOldMap.source,
      name: origPosInOldMap.name
    });
  });
  const generator = mergedMapGenerator;
  oldMapConsumer.sources.forEach((sourceFile) => {
    generator._sources.add(sourceFile);
    const sourceContent = oldMapConsumer.sourceContentFor(sourceFile);
    if (sourceContent != null) {
      mergedMapGenerator.setSourceContent(sourceFile, sourceContent);
    }
  });
  generator._sourceRoot = oldMap.sourceRoot;
  generator._file = oldMap.file;
  return generator.toJSON();
}
function patchErrors(errors, source, inMap) {
  const originalSource = inMap.sourcesContent[0];
  const offset = originalSource.indexOf(source);
  const lineOffset = originalSource.slice(0, offset).split(/\r?\n/).length - 1;
  errors.forEach((err) => {
    if (err.loc) {
      err.loc.start.line += lineOffset;
      err.loc.start.offset += offset;
      if (err.loc.end !== err.loc.start) {
        err.loc.end.line += lineOffset;
        err.loc.end.offset += offset;
      }
    }
  });
}

const trimPlugin = () => {
  return {
    postcssPlugin: "vue-sfc-trim",
    Once(root) {
      root.walk(({ type, raws }) => {
        if (type === "rule" || type === "atrule") {
          if (raws.before)
            raws.before = "\n";
          if ("after" in raws && raws.after)
            raws.after = "\n";
        }
      });
    }
  };
};
trimPlugin.postcss = true;

var dist = {exports: {}};

var processor = {exports: {}};

var parser = {exports: {}};

var root$2 = {exports: {}};

var container = {exports: {}};

var node$1 = {exports: {}};

var util$6 = {};

var unesc = {exports: {}};

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = unesc;
	// Many thanks for this post which made this migration much easier.
	// https://mathiasbynens.be/notes/css-escapes

	/**
	 * 
	 * @param {string} str 
	 * @returns {[string, number]|undefined}
	 */
	function gobbleHex(str) {
	  var lower = str.toLowerCase();
	  var hex = '';
	  var spaceTerminated = false;
	  for (var i = 0; i < 6 && lower[i] !== undefined; i++) {
	    var code = lower.charCodeAt(i);
	    // check to see if we are dealing with a valid hex char [a-f|0-9]
	    var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
	    // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point
	    spaceTerminated = code === 32;
	    if (!valid) {
	      break;
	    }
	    hex += lower[i];
	  }
	  if (hex.length === 0) {
	    return undefined;
	  }
	  var codePoint = parseInt(hex, 16);
	  var isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF;
	  // Add special case for
	  // "If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point"
	  // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point
	  if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {
	    return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
	  }
	  return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
	}
	var CONTAINS_ESCAPE = /\\/;
	function unesc(str) {
	  var needToProcess = CONTAINS_ESCAPE.test(str);
	  if (!needToProcess) {
	    return str;
	  }
	  var ret = "";
	  for (var i = 0; i < str.length; i++) {
	    if (str[i] === "\\") {
	      var gobbled = gobbleHex(str.slice(i + 1, i + 7));
	      if (gobbled !== undefined) {
	        ret += gobbled[0];
	        i += gobbled[1];
	        continue;
	      }

	      // Retain a pair of \\ if double escaped `\\\\`
	      // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e
	      if (str[i + 1] === "\\") {
	        ret += "\\";
	        i++;
	        continue;
	      }

	      // if \\ is at the end of the string retain it
	      // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb
	      if (str.length === i + 1) {
	        ret += str[i];
	      }
	      continue;
	    }
	    ret += str[i];
	  }
	  return ret;
	}
	module.exports = exports.default; 
} (unesc, unesc.exports));

var unescExports = unesc.exports;

var getProp = {exports: {}};

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = getProp;
	function getProp(obj) {
	  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    props[_key - 1] = arguments[_key];
	  }
	  while (props.length > 0) {
	    var prop = props.shift();
	    if (!obj[prop]) {
	      return undefined;
	    }
	    obj = obj[prop];
	  }
	  return obj;
	}
	module.exports = exports.default; 
} (getProp, getProp.exports));

var getPropExports = getProp.exports;

var ensureObject = {exports: {}};

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = ensureObject;
	function ensureObject(obj) {
	  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    props[_key - 1] = arguments[_key];
	  }
	  while (props.length > 0) {
	    var prop = props.shift();
	    if (!obj[prop]) {
	      obj[prop] = {};
	    }
	    obj = obj[prop];
	  }
	}
	module.exports = exports.default; 
} (ensureObject, ensureObject.exports));

var ensureObjectExports = ensureObject.exports;

var stripComments = {exports: {}};

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = stripComments;
	function stripComments(str) {
	  var s = "";
	  var commentStart = str.indexOf("/*");
	  var lastEnd = 0;
	  while (commentStart >= 0) {
	    s = s + str.slice(lastEnd, commentStart);
	    var commentEnd = str.indexOf("*/", commentStart + 2);
	    if (commentEnd < 0) {
	      return s;
	    }
	    lastEnd = commentEnd + 2;
	    commentStart = str.indexOf("/*", lastEnd);
	  }
	  s = s + str.slice(lastEnd);
	  return s;
	}
	module.exports = exports.default; 
} (stripComments, stripComments.exports));

var stripCommentsExports = stripComments.exports;

util$6.__esModule = true;
util$6.unesc = util$6.stripComments = util$6.getProp = util$6.ensureObject = void 0;
var _unesc = _interopRequireDefault$5(unescExports);
util$6.unesc = _unesc["default"];
var _getProp = _interopRequireDefault$5(getPropExports);
util$6.getProp = _getProp["default"];
var _ensureObject = _interopRequireDefault$5(ensureObjectExports);
util$6.ensureObject = _ensureObject["default"];
var _stripComments = _interopRequireDefault$5(stripCommentsExports);
util$6.stripComments = _stripComments["default"];
function _interopRequireDefault$5(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _util = util$6;
	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	var cloneNode = function cloneNode(obj, parent) {
	  if (typeof obj !== 'object' || obj === null) {
	    return obj;
	  }
	  var cloned = new obj.constructor();
	  for (var i in obj) {
	    if (!obj.hasOwnProperty(i)) {
	      continue;
	    }
	    var value = obj[i];
	    var type = typeof value;
	    if (i === 'parent' && type === 'object') {
	      if (parent) {
	        cloned[i] = parent;
	      }
	    } else if (value instanceof Array) {
	      cloned[i] = value.map(function (j) {
	        return cloneNode(j, cloned);
	      });
	    } else {
	      cloned[i] = cloneNode(value, cloned);
	    }
	  }
	  return cloned;
	};
	var Node = /*#__PURE__*/function () {
	  function Node(opts) {
	    if (opts === void 0) {
	      opts = {};
	    }
	    Object.assign(this, opts);
	    this.spaces = this.spaces || {};
	    this.spaces.before = this.spaces.before || '';
	    this.spaces.after = this.spaces.after || '';
	  }
	  var _proto = Node.prototype;
	  _proto.remove = function remove() {
	    if (this.parent) {
	      this.parent.removeChild(this);
	    }
	    this.parent = undefined;
	    return this;
	  };
	  _proto.replaceWith = function replaceWith() {
	    if (this.parent) {
	      for (var index in arguments) {
	        this.parent.insertBefore(this, arguments[index]);
	      }
	      this.remove();
	    }
	    return this;
	  };
	  _proto.next = function next() {
	    return this.parent.at(this.parent.index(this) + 1);
	  };
	  _proto.prev = function prev() {
	    return this.parent.at(this.parent.index(this) - 1);
	  };
	  _proto.clone = function clone(overrides) {
	    if (overrides === void 0) {
	      overrides = {};
	    }
	    var cloned = cloneNode(this);
	    for (var name in overrides) {
	      cloned[name] = overrides[name];
	    }
	    return cloned;
	  }

	  /**
	   * Some non-standard syntax doesn't follow normal escaping rules for css.
	   * This allows non standard syntax to be appended to an existing property
	   * by specifying the escaped value. By specifying the escaped value,
	   * illegal characters are allowed to be directly inserted into css output.
	   * @param {string} name the property to set
	   * @param {any} value the unescaped value of the property
	   * @param {string} valueEscaped optional. the escaped value of the property.
	   */;
	  _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
	    if (!this.raws) {
	      this.raws = {};
	    }
	    var originalValue = this[name];
	    var originalEscaped = this.raws[name];
	    this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.
	    if (originalEscaped || valueEscaped !== value) {
	      this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
	    } else {
	      delete this.raws[name]; // delete any escaped value that was created by the setter.
	    }
	  }

	  /**
	   * Some non-standard syntax doesn't follow normal escaping rules for css.
	   * This allows the escaped value to be specified directly, allowing illegal
	   * characters to be directly inserted into css output.
	   * @param {string} name the property to set
	   * @param {any} value the unescaped value of the property
	   * @param {string} valueEscaped the escaped value of the property.
	   */;
	  _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
	    if (!this.raws) {
	      this.raws = {};
	    }
	    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.
	    this.raws[name] = valueEscaped;
	  }

	  /**
	   * When you want a value to passed through to CSS directly. This method
	   * deletes the corresponding raw value causing the stringifier to fallback
	   * to the unescaped value.
	   * @param {string} name the property to set.
	   * @param {any} value The value that is both escaped and unescaped.
	   */;
	  _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
	    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.
	    if (this.raws) {
	      delete this.raws[name];
	    }
	  }

	  /**
	   *
	   * @param {number} line The number (starting with 1)
	   * @param {number} column The column number (starting with 1)
	   */;
	  _proto.isAtPosition = function isAtPosition(line, column) {
	    if (this.source && this.source.start && this.source.end) {
	      if (this.source.start.line > line) {
	        return false;
	      }
	      if (this.source.end.line < line) {
	        return false;
	      }
	      if (this.source.start.line === line && this.source.start.column > column) {
	        return false;
	      }
	      if (this.source.end.line === line && this.source.end.column < column) {
	        return false;
	      }
	      return true;
	    }
	    return undefined;
	  };
	  _proto.stringifyProperty = function stringifyProperty(name) {
	    return this.raws && this.raws[name] || this[name];
	  };
	  _proto.valueToString = function valueToString() {
	    return String(this.stringifyProperty("value"));
	  };
	  _proto.toString = function toString() {
	    return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join('');
	  };
	  _createClass(Node, [{
	    key: "rawSpaceBefore",
	    get: function get() {
	      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
	      if (rawSpace === undefined) {
	        rawSpace = this.spaces && this.spaces.before;
	      }
	      return rawSpace || "";
	    },
	    set: function set(raw) {
	      (0, _util.ensureObject)(this, "raws", "spaces");
	      this.raws.spaces.before = raw;
	    }
	  }, {
	    key: "rawSpaceAfter",
	    get: function get() {
	      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
	      if (rawSpace === undefined) {
	        rawSpace = this.spaces.after;
	      }
	      return rawSpace || "";
	    },
	    set: function set(raw) {
	      (0, _util.ensureObject)(this, "raws", "spaces");
	      this.raws.spaces.after = raw;
	    }
	  }]);
	  return Node;
	}();
	exports["default"] = Node;
	module.exports = exports.default; 
} (node$1, node$1.exports));

var nodeExports = node$1.exports;

var types$1 = {};

types$1.__esModule = true;
types$1.UNIVERSAL = types$1.TAG = types$1.STRING = types$1.SELECTOR = types$1.ROOT = types$1.PSEUDO = types$1.NESTING = types$1.ID = types$1.COMMENT = types$1.COMBINATOR = types$1.CLASS = types$1.ATTRIBUTE = void 0;
var TAG = 'tag';
types$1.TAG = TAG;
var STRING = 'string';
types$1.STRING = STRING;
var SELECTOR = 'selector';
types$1.SELECTOR = SELECTOR;
var ROOT = 'root';
types$1.ROOT = ROOT;
var PSEUDO = 'pseudo';
types$1.PSEUDO = PSEUDO;
var NESTING = 'nesting';
types$1.NESTING = NESTING;
var ID = 'id';
types$1.ID = ID;
var COMMENT = 'comment';
types$1.COMMENT = COMMENT;
var COMBINATOR = 'combinator';
types$1.COMBINATOR = COMBINATOR;
var CLASS = 'class';
types$1.CLASS = CLASS;
var ATTRIBUTE = 'attribute';
types$1.ATTRIBUTE = ATTRIBUTE;
var UNIVERSAL = 'universal';
types$1.UNIVERSAL = UNIVERSAL;

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _node = _interopRequireDefault(nodeExports);
	var types = _interopRequireWildcard(types$1);
	function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
	function _interopRequireWildcard(obj, nodeInterop) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike  ) { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	var Container = /*#__PURE__*/function (_Node) {
	  _inheritsLoose(Container, _Node);
	  function Container(opts) {
	    var _this;
	    _this = _Node.call(this, opts) || this;
	    if (!_this.nodes) {
	      _this.nodes = [];
	    }
	    return _this;
	  }
	  var _proto = Container.prototype;
	  _proto.append = function append(selector) {
	    selector.parent = this;
	    this.nodes.push(selector);
	    return this;
	  };
	  _proto.prepend = function prepend(selector) {
	    selector.parent = this;
	    this.nodes.unshift(selector);
	    return this;
	  };
	  _proto.at = function at(index) {
	    return this.nodes[index];
	  };
	  _proto.index = function index(child) {
	    if (typeof child === 'number') {
	      return child;
	    }
	    return this.nodes.indexOf(child);
	  };
	  _proto.removeChild = function removeChild(child) {
	    child = this.index(child);
	    this.at(child).parent = undefined;
	    this.nodes.splice(child, 1);
	    var index;
	    for (var id in this.indexes) {
	      index = this.indexes[id];
	      if (index >= child) {
	        this.indexes[id] = index - 1;
	      }
	    }
	    return this;
	  };
	  _proto.removeAll = function removeAll() {
	    for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done;) {
	      var node = _step.value;
	      node.parent = undefined;
	    }
	    this.nodes = [];
	    return this;
	  };
	  _proto.empty = function empty() {
	    return this.removeAll();
	  };
	  _proto.insertAfter = function insertAfter(oldNode, newNode) {
	    newNode.parent = this;
	    var oldIndex = this.index(oldNode);
	    this.nodes.splice(oldIndex + 1, 0, newNode);
	    newNode.parent = this;
	    var index;
	    for (var id in this.indexes) {
	      index = this.indexes[id];
	      if (oldIndex <= index) {
	        this.indexes[id] = index + 1;
	      }
	    }
	    return this;
	  };
	  _proto.insertBefore = function insertBefore(oldNode, newNode) {
	    newNode.parent = this;
	    var oldIndex = this.index(oldNode);
	    this.nodes.splice(oldIndex, 0, newNode);
	    newNode.parent = this;
	    var index;
	    for (var id in this.indexes) {
	      index = this.indexes[id];
	      if (index <= oldIndex) {
	        this.indexes[id] = index + 1;
	      }
	    }
	    return this;
	  };
	  _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
	    var found = undefined;
	    this.each(function (node) {
	      if (node.atPosition) {
	        var foundChild = node.atPosition(line, col);
	        if (foundChild) {
	          found = foundChild;
	          return false;
	        }
	      } else if (node.isAtPosition(line, col)) {
	        found = node;
	        return false;
	      }
	    });
	    return found;
	  }

	  /**
	   * Return the most specific node at the line and column number given.
	   * The source location is based on the original parsed location, locations aren't
	   * updated as selector nodes are mutated.
	   * 
	   * Note that this location is relative to the location of the first character
	   * of the selector, and not the location of the selector in the overall document
	   * when used in conjunction with postcss.
	   *
	   * If not found, returns undefined.
	   * @param {number} line The line number of the node to find. (1-based index)
	   * @param {number} col  The column number of the node to find. (1-based index)
	   */;
	  _proto.atPosition = function atPosition(line, col) {
	    if (this.isAtPosition(line, col)) {
	      return this._findChildAtPosition(line, col) || this;
	    } else {
	      return undefined;
	    }
	  };
	  _proto._inferEndPosition = function _inferEndPosition() {
	    if (this.last && this.last.source && this.last.source.end) {
	      this.source = this.source || {};
	      this.source.end = this.source.end || {};
	      Object.assign(this.source.end, this.last.source.end);
	    }
	  };
	  _proto.each = function each(callback) {
	    if (!this.lastEach) {
	      this.lastEach = 0;
	    }
	    if (!this.indexes) {
	      this.indexes = {};
	    }
	    this.lastEach++;
	    var id = this.lastEach;
	    this.indexes[id] = 0;
	    if (!this.length) {
	      return undefined;
	    }
	    var index, result;
	    while (this.indexes[id] < this.length) {
	      index = this.indexes[id];
	      result = callback(this.at(index), index);
	      if (result === false) {
	        break;
	      }
	      this.indexes[id] += 1;
	    }
	    delete this.indexes[id];
	    if (result === false) {
	      return false;
	    }
	  };
	  _proto.walk = function walk(callback) {
	    return this.each(function (node, i) {
	      var result = callback(node, i);
	      if (result !== false && node.length) {
	        result = node.walk(callback);
	      }
	      if (result === false) {
	        return false;
	      }
	    });
	  };
	  _proto.walkAttributes = function walkAttributes(callback) {
	    var _this2 = this;
	    return this.walk(function (selector) {
	      if (selector.type === types.ATTRIBUTE) {
	        return callback.call(_this2, selector);
	      }
	    });
	  };
	  _proto.walkClasses = function walkClasses(callback) {
	    var _this3 = this;
	    return this.walk(function (selector) {
	      if (selector.type === types.CLASS) {
	        return callback.call(_this3, selector);
	      }
	    });
	  };
	  _proto.walkCombinators = function walkCombinators(callback) {
	    var _this4 = this;
	    return this.walk(function (selector) {
	      if (selector.type === types.COMBINATOR) {
	        return callback.call(_this4, selector);
	      }
	    });
	  };
	  _proto.walkComments = function walkComments(callback) {
	    var _this5 = this;
	    return this.walk(function (selector) {
	      if (selector.type === types.COMMENT) {
	        return callback.call(_this5, selector);
	      }
	    });
	  };
	  _proto.walkIds = function walkIds(callback) {
	    var _this6 = this;
	    return this.walk(function (selector) {
	      if (selector.type === types.ID) {
	        return callback.call(_this6, selector);
	      }
	    });
	  };
	  _proto.walkNesting = function walkNesting(callback) {
	    var _this7 = this;
	    return this.walk(function (selector) {
	      if (selector.type === types.NESTING) {
	        return callback.call(_this7, selector);
	      }
	    });
	  };
	  _proto.walkPseudos = function walkPseudos(callback) {
	    var _this8 = this;
	    return this.walk(function (selector) {
	      if (selector.type === types.PSEUDO) {
	        return callback.call(_this8, selector);
	      }
	    });
	  };
	  _proto.walkTags = function walkTags(callback) {
	    var _this9 = this;
	    return this.walk(function (selector) {
	      if (selector.type === types.TAG) {
	        return callback.call(_this9, selector);
	      }
	    });
	  };
	  _proto.walkUniversals = function walkUniversals(callback) {
	    var _this10 = this;
	    return this.walk(function (selector) {
	      if (selector.type === types.UNIVERSAL) {
	        return callback.call(_this10, selector);
	      }
	    });
	  };
	  _proto.split = function split(callback) {
	    var _this11 = this;
	    var current = [];
	    return this.reduce(function (memo, node, index) {
	      var split = callback.call(_this11, node);
	      current.push(node);
	      if (split) {
	        memo.push(current);
	        current = [];
	      } else if (index === _this11.length - 1) {
	        memo.push(current);
	      }
	      return memo;
	    }, []);
	  };
	  _proto.map = function map(callback) {
	    return this.nodes.map(callback);
	  };
	  _proto.reduce = function reduce(callback, memo) {
	    return this.nodes.reduce(callback, memo);
	  };
	  _proto.every = function every(callback) {
	    return this.nodes.every(callback);
	  };
	  _proto.some = function some(callback) {
	    return this.nodes.some(callback);
	  };
	  _proto.filter = function filter(callback) {
	    return this.nodes.filter(callback);
	  };
	  _proto.sort = function sort(callback) {
	    return this.nodes.sort(callback);
	  };
	  _proto.toString = function toString() {
	    return this.map(String).join('');
	  };
	  _createClass(Container, [{
	    key: "first",
	    get: function get() {
	      return this.at(0);
	    }
	  }, {
	    key: "last",
	    get: function get() {
	      return this.at(this.length - 1);
	    }
	  }, {
	    key: "length",
	    get: function get() {
	      return this.nodes.length;
	    }
	  }]);
	  return Container;
	}(_node["default"]);
	exports["default"] = Container;
	module.exports = exports.default; 
} (container, container.exports));

var containerExports = container.exports;

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _container = _interopRequireDefault(containerExports);
	var _types = types$1;
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	var Root = /*#__PURE__*/function (_Container) {
	  _inheritsLoose(Root, _Container);
	  function Root(opts) {
	    var _this;
	    _this = _Container.call(this, opts) || this;
	    _this.type = _types.ROOT;
	    return _this;
	  }
	  var _proto = Root.prototype;
	  _proto.toString = function toString() {
	    var str = this.reduce(function (memo, selector) {
	      memo.push(String(selector));
	      return memo;
	    }, []).join(',');
	    return this.trailingComma ? str + ',' : str;
	  };
	  _proto.error = function error(message, options) {
	    if (this._error) {
	      return this._error(message, options);
	    } else {
	      return new Error(message);
	    }
	  };
	  _createClass(Root, [{
	    key: "errorGenerator",
	    set: function set(handler) {
	      this._error = handler;
	    }
	  }]);
	  return Root;
	}(_container["default"]);
	exports["default"] = Root;
	module.exports = exports.default; 
} (root$2, root$2.exports));

var rootExports = root$2.exports;

var selector$1 = {exports: {}};

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _container = _interopRequireDefault(containerExports);
	var _types = types$1;
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	var Selector = /*#__PURE__*/function (_Container) {
	  _inheritsLoose(Selector, _Container);
	  function Selector(opts) {
	    var _this;
	    _this = _Container.call(this, opts) || this;
	    _this.type = _types.SELECTOR;
	    return _this;
	  }
	  return Selector;
	}(_container["default"]);
	exports["default"] = Selector;
	module.exports = exports.default; 
} (selector$1, selector$1.exports));

var selectorExports = selector$1.exports;

var className$1 = {exports: {}};

/*! https://mths.be/cssesc v3.0.0 by @mathias */

var object = {};
var hasOwnProperty$1 = object.hasOwnProperty;
var merge$2 = function merge(options, defaults) {
	if (!options) {
		return defaults;
	}
	var result = {};
	for (var key in defaults) {
		// `if (defaults.hasOwnProperty(key) { … }` is not needed here, since
		// only recognized option names are used.
		result[key] = hasOwnProperty$1.call(options, key) ? options[key] : defaults[key];
	}
	return result;
};

var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;

// https://mathiasbynens.be/notes/css-escapes#css
var cssesc = function cssesc(string, options) {
	options = merge$2(options, cssesc.options);
	if (options.quotes != 'single' && options.quotes != 'double') {
		options.quotes = 'single';
	}
	var quote = options.quotes == 'double' ? '"' : '\'';
	var isIdentifier = options.isIdentifier;

	var firstChar = string.charAt(0);
	var output = '';
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var character = string.charAt(counter++);
		var codePoint = character.charCodeAt();
		var value = void 0;
		// If it’s not a printable ASCII character…
		if (codePoint < 0x20 || codePoint > 0x7E) {
			if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
				// It’s a high surrogate, and there is a next character.
				var extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// next character is low surrogate
					codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
				} else {
					// It’s an unmatched surrogate; only append this code unit, in case
					// the next code unit is the high surrogate of a surrogate pair.
					counter--;
				}
			}
			value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
		} else {
			if (options.escapeEverything) {
				if (regexAnySingleEscape.test(character)) {
					value = '\\' + character;
				} else {
					value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
				}
			} else if (/[\t\n\f\r\x0B]/.test(character)) {
				value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
			} else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
				value = '\\' + character;
			} else {
				value = character;
			}
		}
		output += value;
	}

	if (isIdentifier) {
		if (/^-[-\d]/.test(output)) {
			output = '\\-' + output.slice(1);
		} else if (/\d/.test(firstChar)) {
			output = '\\3' + firstChar + ' ' + output.slice(1);
		}
	}

	// Remove spaces after `\HEX` escapes that are not followed by a hex digit,
	// since they’re redundant. Note that this is only possible if the escape
	// sequence isn’t preceded by an odd number of backslashes.
	output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {
		if ($1 && $1.length % 2) {
			// It’s not safe to remove the space, so don’t.
			return $0;
		}
		// Strip the space.
		return ($1 || '') + $2;
	});

	if (!isIdentifier && options.wrap) {
		return quote + output + quote;
	}
	return output;
};

// Expose default options (so they can be overridden globally).
cssesc.options = {
	'escapeEverything': false,
	'isIdentifier': false,
	'quotes': 'single',
	'wrap': false
};

cssesc.version = '3.0.0';

var cssesc_1 = cssesc;

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _cssesc = _interopRequireDefault(cssesc_1);
	var _util = util$6;
	var _node = _interopRequireDefault(nodeExports);
	var _types = types$1;
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	var ClassName = /*#__PURE__*/function (_Node) {
	  _inheritsLoose(ClassName, _Node);
	  function ClassName(opts) {
	    var _this;
	    _this = _Node.call(this, opts) || this;
	    _this.type = _types.CLASS;
	    _this._constructed = true;
	    return _this;
	  }
	  var _proto = ClassName.prototype;
	  _proto.valueToString = function valueToString() {
	    return '.' + _Node.prototype.valueToString.call(this);
	  };
	  _createClass(ClassName, [{
	    key: "value",
	    get: function get() {
	      return this._value;
	    },
	    set: function set(v) {
	      if (this._constructed) {
	        var escaped = (0, _cssesc["default"])(v, {
	          isIdentifier: true
	        });
	        if (escaped !== v) {
	          (0, _util.ensureObject)(this, "raws");
	          this.raws.value = escaped;
	        } else if (this.raws) {
	          delete this.raws.value;
	        }
	      }
	      this._value = v;
	    }
	  }]);
	  return ClassName;
	}(_node["default"]);
	exports["default"] = ClassName;
	module.exports = exports.default; 
} (className$1, className$1.exports));

var classNameExports = className$1.exports;

var comment$2 = {exports: {}};

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _node = _interopRequireDefault(nodeExports);
	var _types = types$1;
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	var Comment = /*#__PURE__*/function (_Node) {
	  _inheritsLoose(Comment, _Node);
	  function Comment(opts) {
	    var _this;
	    _this = _Node.call(this, opts) || this;
	    _this.type = _types.COMMENT;
	    return _this;
	  }
	  return Comment;
	}(_node["default"]);
	exports["default"] = Comment;
	module.exports = exports.default; 
} (comment$2, comment$2.exports));

var commentExports = comment$2.exports;

var id$1 = {exports: {}};

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _node = _interopRequireDefault(nodeExports);
	var _types = types$1;
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	var ID = /*#__PURE__*/function (_Node) {
	  _inheritsLoose(ID, _Node);
	  function ID(opts) {
	    var _this;
	    _this = _Node.call(this, opts) || this;
	    _this.type = _types.ID;
	    return _this;
	  }
	  var _proto = ID.prototype;
	  _proto.valueToString = function valueToString() {
	    return '#' + _Node.prototype.valueToString.call(this);
	  };
	  return ID;
	}(_node["default"]);
	exports["default"] = ID;
	module.exports = exports.default; 
} (id$1, id$1.exports));

var idExports = id$1.exports;

var tag$1 = {exports: {}};

var namespace = {exports: {}};

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _cssesc = _interopRequireDefault(cssesc_1);
	var _util = util$6;
	var _node = _interopRequireDefault(nodeExports);
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	var Namespace = /*#__PURE__*/function (_Node) {
	  _inheritsLoose(Namespace, _Node);
	  function Namespace() {
	    return _Node.apply(this, arguments) || this;
	  }
	  var _proto = Namespace.prototype;
	  _proto.qualifiedName = function qualifiedName(value) {
	    if (this.namespace) {
	      return this.namespaceString + "|" + value;
	    } else {
	      return value;
	    }
	  };
	  _proto.valueToString = function valueToString() {
	    return this.qualifiedName(_Node.prototype.valueToString.call(this));
	  };
	  _createClass(Namespace, [{
	    key: "namespace",
	    get: function get() {
	      return this._namespace;
	    },
	    set: function set(namespace) {
	      if (namespace === true || namespace === "*" || namespace === "&") {
	        this._namespace = namespace;
	        if (this.raws) {
	          delete this.raws.namespace;
	        }
	        return;
	      }
	      var escaped = (0, _cssesc["default"])(namespace, {
	        isIdentifier: true
	      });
	      this._namespace = namespace;
	      if (escaped !== namespace) {
	        (0, _util.ensureObject)(this, "raws");
	        this.raws.namespace = escaped;
	      } else if (this.raws) {
	        delete this.raws.namespace;
	      }
	    }
	  }, {
	    key: "ns",
	    get: function get() {
	      return this._namespace;
	    },
	    set: function set(namespace) {
	      this.namespace = namespace;
	    }
	  }, {
	    key: "namespaceString",
	    get: function get() {
	      if (this.namespace) {
	        var ns = this.stringifyProperty("namespace");
	        if (ns === true) {
	          return '';
	        } else {
	          return ns;
	        }
	      } else {
	        return '';
	      }
	    }
	  }]);
	  return Namespace;
	}(_node["default"]);
	exports["default"] = Namespace;
	module.exports = exports.default; 
} (namespace, namespace.exports));

var namespaceExports = namespace.exports;

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _namespace = _interopRequireDefault(namespaceExports);
	var _types = types$1;
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	var Tag = /*#__PURE__*/function (_Namespace) {
	  _inheritsLoose(Tag, _Namespace);
	  function Tag(opts) {
	    var _this;
	    _this = _Namespace.call(this, opts) || this;
	    _this.type = _types.TAG;
	    return _this;
	  }
	  return Tag;
	}(_namespace["default"]);
	exports["default"] = Tag;
	module.exports = exports.default; 
} (tag$1, tag$1.exports));

var tagExports = tag$1.exports;

var string$1 = {exports: {}};

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _node = _interopRequireDefault(nodeExports);
	var _types = types$1;
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	var String = /*#__PURE__*/function (_Node) {
	  _inheritsLoose(String, _Node);
	  function String(opts) {
	    var _this;
	    _this = _Node.call(this, opts) || this;
	    _this.type = _types.STRING;
	    return _this;
	  }
	  return String;
	}(_node["default"]);
	exports["default"] = String;
	module.exports = exports.default; 
} (string$1, string$1.exports));

var stringExports = string$1.exports;

var pseudo$1 = {exports: {}};

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _container = _interopRequireDefault(containerExports);
	var _types = types$1;
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	var Pseudo = /*#__PURE__*/function (_Container) {
	  _inheritsLoose(Pseudo, _Container);
	  function Pseudo(opts) {
	    var _this;
	    _this = _Container.call(this, opts) || this;
	    _this.type = _types.PSEUDO;
	    return _this;
	  }
	  var _proto = Pseudo.prototype;
	  _proto.toString = function toString() {
	    var params = this.length ? '(' + this.map(String).join(',') + ')' : '';
	    return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join('');
	  };
	  return Pseudo;
	}(_container["default"]);
	exports["default"] = Pseudo;
	module.exports = exports.default; 
} (pseudo$1, pseudo$1.exports));

var pseudoExports = pseudo$1.exports;

var attribute$1 = {};

/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */

var node = require$$2.deprecate;

(function (exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	exports.unescapeValue = unescapeValue;
	var _cssesc = _interopRequireDefault(cssesc_1);
	var _unesc = _interopRequireDefault(unescExports);
	var _namespace = _interopRequireDefault(namespaceExports);
	var _types = types$1;
	var _CSSESC_QUOTE_OPTIONS;
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	var deprecate = node;
	var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
	var warnOfDeprecatedValueAssignment = deprecate(function () {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. " + "Call attribute.setValue() instead.");
	var warnOfDeprecatedQuotedAssignment = deprecate(function () {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
	var warnOfDeprecatedConstructor = deprecate(function () {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
	function unescapeValue(value) {
	  var deprecatedUsage = false;
	  var quoteMark = null;
	  var unescaped = value;
	  var m = unescaped.match(WRAPPED_IN_QUOTES);
	  if (m) {
	    quoteMark = m[1];
	    unescaped = m[2];
	  }
	  unescaped = (0, _unesc["default"])(unescaped);
	  if (unescaped !== value) {
	    deprecatedUsage = true;
	  }
	  return {
	    deprecatedUsage: deprecatedUsage,
	    unescaped: unescaped,
	    quoteMark: quoteMark
	  };
	}
	function handleDeprecatedContructorOpts(opts) {
	  if (opts.quoteMark !== undefined) {
	    return opts;
	  }
	  if (opts.value === undefined) {
	    return opts;
	  }
	  warnOfDeprecatedConstructor();
	  var _unescapeValue = unescapeValue(opts.value),
	    quoteMark = _unescapeValue.quoteMark,
	    unescaped = _unescapeValue.unescaped;
	  if (!opts.raws) {
	    opts.raws = {};
	  }
	  if (opts.raws.value === undefined) {
	    opts.raws.value = opts.value;
	  }
	  opts.value = unescaped;
	  opts.quoteMark = quoteMark;
	  return opts;
	}
	var Attribute = /*#__PURE__*/function (_Namespace) {
	  _inheritsLoose(Attribute, _Namespace);
	  function Attribute(opts) {
	    var _this;
	    if (opts === void 0) {
	      opts = {};
	    }
	    _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
	    _this.type = _types.ATTRIBUTE;
	    _this.raws = _this.raws || {};
	    Object.defineProperty(_this.raws, 'unquoted', {
	      get: deprecate(function () {
	        return _this.value;
	      }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
	      set: deprecate(function () {
	        return _this.value;
	      }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
	    });
	    _this._constructed = true;
	    return _this;
	  }

	  /**
	   * Returns the Attribute's value quoted such that it would be legal to use
	   * in the value of a css file. The original value's quotation setting
	   * used for stringification is left unchanged. See `setValue(value, options)`
	   * if you want to control the quote settings of a new value for the attribute.
	   *
	   * You can also change the quotation used for the current value by setting quoteMark.
	   *
	   * Options:
	   *   * quoteMark {'"' | "'" | null} - Use this value to quote the value. If this
	   *     option is not set, the original value for quoteMark will be used. If
	   *     indeterminate, a double quote is used. The legal values are:
	   *     * `null` - the value will be unquoted and characters will be escaped as necessary.
	   *     * `'` - the value will be quoted with a single quote and single quotes are escaped.
	   *     * `"` - the value will be quoted with a double quote and double quotes are escaped.
	   *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark
	   *     over the quoteMark option value.
	   *   * smart {boolean} - if true, will select a quote mark based on the value
	   *     and the other options specified here. See the `smartQuoteMark()`
	   *     method.
	   **/
	  var _proto = Attribute.prototype;
	  _proto.getQuotedValue = function getQuotedValue(options) {
	    if (options === void 0) {
	      options = {};
	    }
	    var quoteMark = this._determineQuoteMark(options);
	    var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
	    var escaped = (0, _cssesc["default"])(this._value, cssescopts);
	    return escaped;
	  };
	  _proto._determineQuoteMark = function _determineQuoteMark(options) {
	    return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
	  }

	  /**
	   * Set the unescaped value with the specified quotation options. The value
	   * provided must not include any wrapping quote marks -- those quotes will
	   * be interpreted as part of the value and escaped accordingly.
	   */;
	  _proto.setValue = function setValue(value, options) {
	    if (options === void 0) {
	      options = {};
	    }
	    this._value = value;
	    this._quoteMark = this._determineQuoteMark(options);
	    this._syncRawValue();
	  }

	  /**
	   * Intelligently select a quoteMark value based on the value's contents. If
	   * the value is a legal CSS ident, it will not be quoted. Otherwise a quote
	   * mark will be picked that minimizes the number of escapes.
	   *
	   * If there's no clear winner, the quote mark from these options is used,
	   * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is
	   * true). If the quoteMark is unspecified, a double quote is used.
	   *
	   * @param options This takes the quoteMark and preferCurrentQuoteMark options
	   * from the quoteValue method.
	   */;
	  _proto.smartQuoteMark = function smartQuoteMark(options) {
	    var v = this.value;
	    var numSingleQuotes = v.replace(/[^']/g, '').length;
	    var numDoubleQuotes = v.replace(/[^"]/g, '').length;
	    if (numSingleQuotes + numDoubleQuotes === 0) {
	      var escaped = (0, _cssesc["default"])(v, {
	        isIdentifier: true
	      });
	      if (escaped === v) {
	        return Attribute.NO_QUOTE;
	      } else {
	        var pref = this.preferredQuoteMark(options);
	        if (pref === Attribute.NO_QUOTE) {
	          // pick a quote mark that isn't none and see if it's smaller
	          var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;
	          var opts = CSSESC_QUOTE_OPTIONS[quote];
	          var quoteValue = (0, _cssesc["default"])(v, opts);
	          if (quoteValue.length < escaped.length) {
	            return quote;
	          }
	        }
	        return pref;
	      }
	    } else if (numDoubleQuotes === numSingleQuotes) {
	      return this.preferredQuoteMark(options);
	    } else if (numDoubleQuotes < numSingleQuotes) {
	      return Attribute.DOUBLE_QUOTE;
	    } else {
	      return Attribute.SINGLE_QUOTE;
	    }
	  }

	  /**
	   * Selects the preferred quote mark based on the options and the current quote mark value.
	   * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`
	   * instead.
	   */;
	  _proto.preferredQuoteMark = function preferredQuoteMark(options) {
	    var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;
	    if (quoteMark === undefined) {
	      quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
	    }
	    if (quoteMark === undefined) {
	      quoteMark = Attribute.DOUBLE_QUOTE;
	    }
	    return quoteMark;
	  };
	  _proto._syncRawValue = function _syncRawValue() {
	    var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
	    if (rawValue === this._value) {
	      if (this.raws) {
	        delete this.raws.value;
	      }
	    } else {
	      this.raws.value = rawValue;
	    }
	  };
	  _proto._handleEscapes = function _handleEscapes(prop, value) {
	    if (this._constructed) {
	      var escaped = (0, _cssesc["default"])(value, {
	        isIdentifier: true
	      });
	      if (escaped !== value) {
	        this.raws[prop] = escaped;
	      } else {
	        delete this.raws[prop];
	      }
	    }
	  };
	  _proto._spacesFor = function _spacesFor(name) {
	    var attrSpaces = {
	      before: '',
	      after: ''
	    };
	    var spaces = this.spaces[name] || {};
	    var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
	    return Object.assign(attrSpaces, spaces, rawSpaces);
	  };
	  _proto._stringFor = function _stringFor(name, spaceName, concat) {
	    if (spaceName === void 0) {
	      spaceName = name;
	    }
	    if (concat === void 0) {
	      concat = defaultAttrConcat;
	    }
	    var attrSpaces = this._spacesFor(spaceName);
	    return concat(this.stringifyProperty(name), attrSpaces);
	  }

	  /**
	   * returns the offset of the attribute part specified relative to the
	   * start of the node of the output string.
	   *
	   * * "ns" - alias for "namespace"
	   * * "namespace" - the namespace if it exists.
	   * * "attribute" - the attribute name
	   * * "attributeNS" - the start of the attribute or its namespace
	   * * "operator" - the match operator of the attribute
	   * * "value" - The value (string or identifier)
	   * * "insensitive" - the case insensitivity flag;
	   * @param part One of the possible values inside an attribute.
	   * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
	   */;
	  _proto.offsetOf = function offsetOf(name) {
	    var count = 1;
	    var attributeSpaces = this._spacesFor("attribute");
	    count += attributeSpaces.before.length;
	    if (name === "namespace" || name === "ns") {
	      return this.namespace ? count : -1;
	    }
	    if (name === "attributeNS") {
	      return count;
	    }
	    count += this.namespaceString.length;
	    if (this.namespace) {
	      count += 1;
	    }
	    if (name === "attribute") {
	      return count;
	    }
	    count += this.stringifyProperty("attribute").length;
	    count += attributeSpaces.after.length;
	    var operatorSpaces = this._spacesFor("operator");
	    count += operatorSpaces.before.length;
	    var operator = this.stringifyProperty("operator");
	    if (name === "operator") {
	      return operator ? count : -1;
	    }
	    count += operator.length;
	    count += operatorSpaces.after.length;
	    var valueSpaces = this._spacesFor("value");
	    count += valueSpaces.before.length;
	    var value = this.stringifyProperty("value");
	    if (name === "value") {
	      return value ? count : -1;
	    }
	    count += value.length;
	    count += valueSpaces.after.length;
	    var insensitiveSpaces = this._spacesFor("insensitive");
	    count += insensitiveSpaces.before.length;
	    if (name === "insensitive") {
	      return this.insensitive ? count : -1;
	    }
	    return -1;
	  };
	  _proto.toString = function toString() {
	    var _this2 = this;
	    var selector = [this.rawSpaceBefore, '['];
	    selector.push(this._stringFor('qualifiedAttribute', 'attribute'));
	    if (this.operator && (this.value || this.value === '')) {
	      selector.push(this._stringFor('operator'));
	      selector.push(this._stringFor('value'));
	      selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {
	        if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
	          attrSpaces.before = " ";
	        }
	        return defaultAttrConcat(attrValue, attrSpaces);
	      }));
	    }
	    selector.push(']');
	    selector.push(this.rawSpaceAfter);
	    return selector.join('');
	  };
	  _createClass(Attribute, [{
	    key: "quoted",
	    get: function get() {
	      var qm = this.quoteMark;
	      return qm === "'" || qm === '"';
	    },
	    set: function set(value) {
	      warnOfDeprecatedQuotedAssignment();
	    }

	    /**
	     * returns a single (`'`) or double (`"`) quote character if the value is quoted.
	     * returns `null` if the value is not quoted.
	     * returns `undefined` if the quotation state is unknown (this can happen when
	     * the attribute is constructed without specifying a quote mark.)
	     */
	  }, {
	    key: "quoteMark",
	    get: function get() {
	      return this._quoteMark;
	    }

	    /**
	     * Set the quote mark to be used by this attribute's value.
	     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute
	     * value is updated accordingly.
	     *
	     * @param {"'" | '"' | null} quoteMark The quote mark or `null` if the value should be unquoted.
	     */,
	    set: function set(quoteMark) {
	      if (!this._constructed) {
	        this._quoteMark = quoteMark;
	        return;
	      }
	      if (this._quoteMark !== quoteMark) {
	        this._quoteMark = quoteMark;
	        this._syncRawValue();
	      }
	    }
	  }, {
	    key: "qualifiedAttribute",
	    get: function get() {
	      return this.qualifiedName(this.raws.attribute || this.attribute);
	    }
	  }, {
	    key: "insensitiveFlag",
	    get: function get() {
	      return this.insensitive ? 'i' : '';
	    }
	  }, {
	    key: "value",
	    get: function get() {
	      return this._value;
	    },
	    set:
	    /**
	     * Before 3.0, the value had to be set to an escaped value including any wrapped
	     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
	     * is unescaped during parsing and any quote marks are removed.
	     *
	     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
	     * a deprecation warning is raised when the new value contains any characters that would
	     * require escaping (including if it contains wrapped quotes).
	     *
	     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
	     * how the new value is quoted.
	     */
	    function set(v) {
	      if (this._constructed) {
	        var _unescapeValue2 = unescapeValue(v),
	          deprecatedUsage = _unescapeValue2.deprecatedUsage,
	          unescaped = _unescapeValue2.unescaped,
	          quoteMark = _unescapeValue2.quoteMark;
	        if (deprecatedUsage) {
	          warnOfDeprecatedValueAssignment();
	        }
	        if (unescaped === this._value && quoteMark === this._quoteMark) {
	          return;
	        }
	        this._value = unescaped;
	        this._quoteMark = quoteMark;
	        this._syncRawValue();
	      } else {
	        this._value = v;
	      }
	    }
	  }, {
	    key: "insensitive",
	    get: function get() {
	      return this._insensitive;
	    }

	    /**
	     * Set the case insensitive flag.
	     * If the case insensitive flag changes, the raw (escaped) value at `attr.raws.insensitiveFlag`
	     * of the attribute is updated accordingly.
	     *
	     * @param {true | false} insensitive true if the attribute should match case-insensitively.
	     */,
	    set: function set(insensitive) {
	      if (!insensitive) {
	        this._insensitive = false;

	        // "i" and "I" can be used in "this.raws.insensitiveFlag" to store the original notation.
	        // When setting `attr.insensitive = false` both should be erased to ensure correct serialization.
	        if (this.raws && (this.raws.insensitiveFlag === 'I' || this.raws.insensitiveFlag === 'i')) {
	          this.raws.insensitiveFlag = undefined;
	        }
	      }
	      this._insensitive = insensitive;
	    }
	  }, {
	    key: "attribute",
	    get: function get() {
	      return this._attribute;
	    },
	    set: function set(name) {
	      this._handleEscapes("attribute", name);
	      this._attribute = name;
	    }
	  }]);
	  return Attribute;
	}(_namespace["default"]);
	exports["default"] = Attribute;
	Attribute.NO_QUOTE = null;
	Attribute.SINGLE_QUOTE = "'";
	Attribute.DOUBLE_QUOTE = '"';
	var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
	  "'": {
	    quotes: 'single',
	    wrap: true
	  },
	  '"': {
	    quotes: 'double',
	    wrap: true
	  }
	}, _CSSESC_QUOTE_OPTIONS[null] = {
	  isIdentifier: true
	}, _CSSESC_QUOTE_OPTIONS);
	function defaultAttrConcat(attrValue, attrSpaces) {
	  return "" + attrSpaces.before + attrValue + attrSpaces.after;
	} 
} (attribute$1));

var universal$1 = {exports: {}};

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _namespace = _interopRequireDefault(namespaceExports);
	var _types = types$1;
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	var Universal = /*#__PURE__*/function (_Namespace) {
	  _inheritsLoose(Universal, _Namespace);
	  function Universal(opts) {
	    var _this;
	    _this = _Namespace.call(this, opts) || this;
	    _this.type = _types.UNIVERSAL;
	    _this.value = '*';
	    return _this;
	  }
	  return Universal;
	}(_namespace["default"]);
	exports["default"] = Universal;
	module.exports = exports.default; 
} (universal$1, universal$1.exports));

var universalExports = universal$1.exports;

var combinator$2 = {exports: {}};

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _node = _interopRequireDefault(nodeExports);
	var _types = types$1;
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	var Combinator = /*#__PURE__*/function (_Node) {
	  _inheritsLoose(Combinator, _Node);
	  function Combinator(opts) {
	    var _this;
	    _this = _Node.call(this, opts) || this;
	    _this.type = _types.COMBINATOR;
	    return _this;
	  }
	  return Combinator;
	}(_node["default"]);
	exports["default"] = Combinator;
	module.exports = exports.default; 
} (combinator$2, combinator$2.exports));

var combinatorExports = combinator$2.exports;

var nesting$1 = {exports: {}};

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _node = _interopRequireDefault(nodeExports);
	var _types = types$1;
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	var Nesting = /*#__PURE__*/function (_Node) {
	  _inheritsLoose(Nesting, _Node);
	  function Nesting(opts) {
	    var _this;
	    _this = _Node.call(this, opts) || this;
	    _this.type = _types.NESTING;
	    _this.value = '&';
	    return _this;
	  }
	  return Nesting;
	}(_node["default"]);
	exports["default"] = Nesting;
	module.exports = exports.default; 
} (nesting$1, nesting$1.exports));

var nestingExports = nesting$1.exports;

var sortAscending = {exports: {}};

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = sortAscending;
	function sortAscending(list) {
	  return list.sort(function (a, b) {
	    return a - b;
	  });
	}
	module.exports = exports.default; 
} (sortAscending, sortAscending.exports));

var sortAscendingExports = sortAscending.exports;

var tokenize = {};

var tokenTypes = {};

tokenTypes.__esModule = true;
tokenTypes.word = tokenTypes.tilde = tokenTypes.tab = tokenTypes.str = tokenTypes.space = tokenTypes.slash = tokenTypes.singleQuote = tokenTypes.semicolon = tokenTypes.plus = tokenTypes.pipe = tokenTypes.openSquare = tokenTypes.openParenthesis = tokenTypes.newline = tokenTypes.greaterThan = tokenTypes.feed = tokenTypes.equals = tokenTypes.doubleQuote = tokenTypes.dollar = tokenTypes.cr = tokenTypes.comment = tokenTypes.comma = tokenTypes.combinator = tokenTypes.colon = tokenTypes.closeSquare = tokenTypes.closeParenthesis = tokenTypes.caret = tokenTypes.bang = tokenTypes.backslash = tokenTypes.at = tokenTypes.asterisk = tokenTypes.ampersand = void 0;
var ampersand = 38; // `&`.charCodeAt(0);
tokenTypes.ampersand = ampersand;
var asterisk = 42; // `*`.charCodeAt(0);
tokenTypes.asterisk = asterisk;
var at = 64; // `@`.charCodeAt(0);
tokenTypes.at = at;
var comma$1 = 44; // `,`.charCodeAt(0);
tokenTypes.comma = comma$1;
var colon$1 = 58; // `:`.charCodeAt(0);
tokenTypes.colon = colon$1;
var semicolon = 59; // `;`.charCodeAt(0);
tokenTypes.semicolon = semicolon;
var openParenthesis = 40; // `(`.charCodeAt(0);
tokenTypes.openParenthesis = openParenthesis;
var closeParenthesis = 41; // `)`.charCodeAt(0);
tokenTypes.closeParenthesis = closeParenthesis;
var openSquare = 91; // `[`.charCodeAt(0);
tokenTypes.openSquare = openSquare;
var closeSquare = 93; // `]`.charCodeAt(0);
tokenTypes.closeSquare = closeSquare;
var dollar = 36; // `$`.charCodeAt(0);
tokenTypes.dollar = dollar;
var tilde = 126; // `~`.charCodeAt(0);
tokenTypes.tilde = tilde;
var caret = 94; // `^`.charCodeAt(0);
tokenTypes.caret = caret;
var plus$1 = 43; // `+`.charCodeAt(0);
tokenTypes.plus = plus$1;
var equals = 61; // `=`.charCodeAt(0);
tokenTypes.equals = equals;
var pipe = 124; // `|`.charCodeAt(0);
tokenTypes.pipe = pipe;
var greaterThan = 62; // `>`.charCodeAt(0);
tokenTypes.greaterThan = greaterThan;
var space = 32; // ` `.charCodeAt(0);
tokenTypes.space = space;
var singleQuote$1 = 39; // `'`.charCodeAt(0);
tokenTypes.singleQuote = singleQuote$1;
var doubleQuote$1 = 34; // `"`.charCodeAt(0);
tokenTypes.doubleQuote = doubleQuote$1;
var slash$1 = 47; // `/`.charCodeAt(0);
tokenTypes.slash = slash$1;
var bang = 33; // `!`.charCodeAt(0);
tokenTypes.bang = bang;
var backslash$1 = 92; // '\\'.charCodeAt(0);
tokenTypes.backslash = backslash$1;
var cr = 13; // '\r'.charCodeAt(0);
tokenTypes.cr = cr;
var feed = 12; // '\f'.charCodeAt(0);
tokenTypes.feed = feed;
var newline = 10; // '\n'.charCodeAt(0);
tokenTypes.newline = newline;
var tab = 9; // '\t'.charCodeAt(0);

// Expose aliases primarily for readability.
tokenTypes.tab = tab;
var str = singleQuote$1;

// No good single character representation!
tokenTypes.str = str;
var comment$1 = -1;
tokenTypes.comment = comment$1;
var word = -2;
tokenTypes.word = word;
var combinator$1 = -3;
tokenTypes.combinator = combinator$1;

(function (exports) {

	exports.__esModule = true;
	exports.FIELDS = void 0;
	exports["default"] = tokenize;
	var t = _interopRequireWildcard(tokenTypes);
	var _unescapable, _wordDelimiters;
	function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
	function _interopRequireWildcard(obj, nodeInterop) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
	var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
	var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
	var hex = {};
	var hexChars = "0123456789abcdefABCDEF";
	for (var i = 0; i < hexChars.length; i++) {
	  hex[hexChars.charCodeAt(i)] = true;
	}

	/**
	 *  Returns the last index of the bar css word
	 * @param {string} css The string in which the word begins
	 * @param {number} start The index into the string where word's first letter occurs
	 */
	function consumeWord(css, start) {
	  var next = start;
	  var code;
	  do {
	    code = css.charCodeAt(next);
	    if (wordDelimiters[code]) {
	      return next - 1;
	    } else if (code === t.backslash) {
	      next = consumeEscape(css, next) + 1;
	    } else {
	      // All other characters are part of the word
	      next++;
	    }
	  } while (next < css.length);
	  return next - 1;
	}

	/**
	 *  Returns the last index of the escape sequence
	 * @param {string} css The string in which the sequence begins
	 * @param {number} start The index into the string where escape character (`\`) occurs.
	 */
	function consumeEscape(css, start) {
	  var next = start;
	  var code = css.charCodeAt(next + 1);
	  if (unescapable[code]) ; else if (hex[code]) {
	    var hexDigits = 0;
	    // consume up to 6 hex chars
	    do {
	      next++;
	      hexDigits++;
	      code = css.charCodeAt(next + 1);
	    } while (hex[code] && hexDigits < 6);
	    // if fewer than 6 hex chars, a trailing space ends the escape
	    if (hexDigits < 6 && code === t.space) {
	      next++;
	    }
	  } else {
	    // the next char is part of the current word
	    next++;
	  }
	  return next;
	}
	var FIELDS = {
	  TYPE: 0,
	  START_LINE: 1,
	  START_COL: 2,
	  END_LINE: 3,
	  END_COL: 4,
	  START_POS: 5,
	  END_POS: 6
	};
	exports.FIELDS = FIELDS;
	function tokenize(input) {
	  var tokens = [];
	  var css = input.css.valueOf();
	  var _css = css,
	    length = _css.length;
	  var offset = -1;
	  var line = 1;
	  var start = 0;
	  var end = 0;
	  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;
	  function unclosed(what, fix) {
	    if (input.safe) {
	      // fyi: this is never set to true.
	      css += fix;
	      next = css.length - 1;
	    } else {
	      throw input.error('Unclosed ' + what, line, start - offset, start);
	    }
	  }
	  while (start < length) {
	    code = css.charCodeAt(start);
	    if (code === t.newline) {
	      offset = start;
	      line += 1;
	    }
	    switch (code) {
	      case t.space:
	      case t.tab:
	      case t.newline:
	      case t.cr:
	      case t.feed:
	        next = start;
	        do {
	          next += 1;
	          code = css.charCodeAt(next);
	          if (code === t.newline) {
	            offset = next;
	            line += 1;
	          }
	        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);
	        tokenType = t.space;
	        endLine = line;
	        endColumn = next - offset - 1;
	        end = next;
	        break;
	      case t.plus:
	      case t.greaterThan:
	      case t.tilde:
	      case t.pipe:
	        next = start;
	        do {
	          next += 1;
	          code = css.charCodeAt(next);
	        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);
	        tokenType = t.combinator;
	        endLine = line;
	        endColumn = start - offset;
	        end = next;
	        break;

	      // Consume these characters as single tokens.
	      case t.asterisk:
	      case t.ampersand:
	      case t.bang:
	      case t.comma:
	      case t.equals:
	      case t.dollar:
	      case t.caret:
	      case t.openSquare:
	      case t.closeSquare:
	      case t.colon:
	      case t.semicolon:
	      case t.openParenthesis:
	      case t.closeParenthesis:
	        next = start;
	        tokenType = code;
	        endLine = line;
	        endColumn = start - offset;
	        end = next + 1;
	        break;
	      case t.singleQuote:
	      case t.doubleQuote:
	        quote = code === t.singleQuote ? "'" : '"';
	        next = start;
	        do {
	          escaped = false;
	          next = css.indexOf(quote, next + 1);
	          if (next === -1) {
	            unclosed('quote', quote);
	          }
	          escapePos = next;
	          while (css.charCodeAt(escapePos - 1) === t.backslash) {
	            escapePos -= 1;
	            escaped = !escaped;
	          }
	        } while (escaped);
	        tokenType = t.str;
	        endLine = line;
	        endColumn = start - offset;
	        end = next + 1;
	        break;
	      default:
	        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
	          next = css.indexOf('*/', start + 2) + 1;
	          if (next === 0) {
	            unclosed('comment', '*/');
	          }
	          content = css.slice(start, next + 1);
	          lines = content.split('\n');
	          last = lines.length - 1;
	          if (last > 0) {
	            nextLine = line + last;
	            nextOffset = next - lines[last].length;
	          } else {
	            nextLine = line;
	            nextOffset = offset;
	          }
	          tokenType = t.comment;
	          line = nextLine;
	          endLine = nextLine;
	          endColumn = next - nextOffset;
	        } else if (code === t.slash) {
	          next = start;
	          tokenType = code;
	          endLine = line;
	          endColumn = start - offset;
	          end = next + 1;
	        } else {
	          next = consumeWord(css, start);
	          tokenType = t.word;
	          endLine = line;
	          endColumn = next - offset;
	        }
	        end = next + 1;
	        break;
	    }

	    // Ensure that the token structure remains consistent
	    tokens.push([tokenType,
	    // [0] Token type
	    line,
	    // [1] Starting line
	    start - offset,
	    // [2] Starting column
	    endLine,
	    // [3] Ending line
	    endColumn,
	    // [4] Ending column
	    start,
	    // [5] Start position / Source index
	    end // [6] End position
	    ]);

	    // Reset offset for the next token
	    if (nextOffset) {
	      offset = nextOffset;
	      nextOffset = null;
	    }
	    start = end;
	  }
	  return tokens;
	} 
} (tokenize));

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _root = _interopRequireDefault(rootExports);
	var _selector = _interopRequireDefault(selectorExports);
	var _className = _interopRequireDefault(classNameExports);
	var _comment = _interopRequireDefault(commentExports);
	var _id = _interopRequireDefault(idExports);
	var _tag = _interopRequireDefault(tagExports);
	var _string = _interopRequireDefault(stringExports);
	var _pseudo = _interopRequireDefault(pseudoExports);
	var _attribute = _interopRequireWildcard(attribute$1);
	var _universal = _interopRequireDefault(universalExports);
	var _combinator = _interopRequireDefault(combinatorExports);
	var _nesting = _interopRequireDefault(nestingExports);
	var _sortAscending = _interopRequireDefault(sortAscendingExports);
	var _tokenize = _interopRequireWildcard(tokenize);
	var tokens = _interopRequireWildcard(tokenTypes);
	var types = _interopRequireWildcard(types$1);
	var _util = util$6;
	var _WHITESPACE_TOKENS, _Object$assign;
	function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
	function _interopRequireWildcard(obj, nodeInterop) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
	var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
	function tokenStart(token) {
	  return {
	    line: token[_tokenize.FIELDS.START_LINE],
	    column: token[_tokenize.FIELDS.START_COL]
	  };
	}
	function tokenEnd(token) {
	  return {
	    line: token[_tokenize.FIELDS.END_LINE],
	    column: token[_tokenize.FIELDS.END_COL]
	  };
	}
	function getSource(startLine, startColumn, endLine, endColumn) {
	  return {
	    start: {
	      line: startLine,
	      column: startColumn
	    },
	    end: {
	      line: endLine,
	      column: endColumn
	    }
	  };
	}
	function getTokenSource(token) {
	  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
	}
	function getTokenSourceSpan(startToken, endToken) {
	  if (!startToken) {
	    return undefined;
	  }
	  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
	}
	function unescapeProp(node, prop) {
	  var value = node[prop];
	  if (typeof value !== "string") {
	    return;
	  }
	  if (value.indexOf("\\") !== -1) {
	    (0, _util.ensureObject)(node, 'raws');
	    node[prop] = (0, _util.unesc)(value);
	    if (node.raws[prop] === undefined) {
	      node.raws[prop] = value;
	    }
	  }
	  return node;
	}
	function indexesOf(array, item) {
	  var i = -1;
	  var indexes = [];
	  while ((i = array.indexOf(item, i + 1)) !== -1) {
	    indexes.push(i);
	  }
	  return indexes;
	}
	function uniqs() {
	  var list = Array.prototype.concat.apply([], arguments);
	  return list.filter(function (item, i) {
	    return i === list.indexOf(item);
	  });
	}
	var Parser = /*#__PURE__*/function () {
	  function Parser(rule, options) {
	    if (options === void 0) {
	      options = {};
	    }
	    this.rule = rule;
	    this.options = Object.assign({
	      lossy: false,
	      safe: false
	    }, options);
	    this.position = 0;
	    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;
	    this.tokens = (0, _tokenize["default"])({
	      css: this.css,
	      error: this._errorGenerator(),
	      safe: this.options.safe
	    });
	    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
	    this.root = new _root["default"]({
	      source: rootSource
	    });
	    this.root.errorGenerator = this._errorGenerator();
	    var selector = new _selector["default"]({
	      source: {
	        start: {
	          line: 1,
	          column: 1
	        }
	      }
	    });
	    this.root.append(selector);
	    this.current = selector;
	    this.loop();
	  }
	  var _proto = Parser.prototype;
	  _proto._errorGenerator = function _errorGenerator() {
	    var _this = this;
	    return function (message, errorOptions) {
	      if (typeof _this.rule === 'string') {
	        return new Error(message);
	      }
	      return _this.rule.error(message, errorOptions);
	    };
	  };
	  _proto.attribute = function attribute() {
	    var attr = [];
	    var startingToken = this.currToken;
	    this.position++;
	    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
	      attr.push(this.currToken);
	      this.position++;
	    }
	    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
	      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
	    }
	    var len = attr.length;
	    var node = {
	      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
	      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
	    };
	    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
	      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);
	    }
	    var pos = 0;
	    var spaceBefore = '';
	    var commentBefore = '';
	    var lastAdded = null;
	    var spaceAfterMeaningfulToken = false;
	    while (pos < len) {
	      var token = attr[pos];
	      var content = this.content(token);
	      var next = attr[pos + 1];
	      switch (token[_tokenize.FIELDS.TYPE]) {
	        case tokens.space:
	          // if (
	          //     len === 1 ||
	          //     pos === 0 && this.content(next) === '|'
	          // ) {
	          //     return this.expected('attribute', token[TOKEN.START_POS], content);
	          // }
	          spaceAfterMeaningfulToken = true;
	          if (this.options.lossy) {
	            break;
	          }
	          if (lastAdded) {
	            (0, _util.ensureObject)(node, 'spaces', lastAdded);
	            var prevContent = node.spaces[lastAdded].after || '';
	            node.spaces[lastAdded].after = prevContent + content;
	            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;
	            if (existingComment) {
	              node.raws.spaces[lastAdded].after = existingComment + content;
	            }
	          } else {
	            spaceBefore = spaceBefore + content;
	            commentBefore = commentBefore + content;
	          }
	          break;
	        case tokens.asterisk:
	          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
	            node.operator = content;
	            lastAdded = 'operator';
	          } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
	            if (spaceBefore) {
	              (0, _util.ensureObject)(node, 'spaces', 'attribute');
	              node.spaces.attribute.before = spaceBefore;
	              spaceBefore = '';
	            }
	            if (commentBefore) {
	              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
	              node.raws.spaces.attribute.before = spaceBefore;
	              commentBefore = '';
	            }
	            node.namespace = (node.namespace || "") + content;
	            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;
	            if (rawValue) {
	              node.raws.namespace += content;
	            }
	            lastAdded = 'namespace';
	          }
	          spaceAfterMeaningfulToken = false;
	          break;
	        case tokens.dollar:
	          if (lastAdded === "value") {
	            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');
	            node.value += "$";
	            if (oldRawValue) {
	              node.raws.value = oldRawValue + "$";
	            }
	            break;
	          }
	        // Falls through
	        case tokens.caret:
	          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
	            node.operator = content;
	            lastAdded = 'operator';
	          }
	          spaceAfterMeaningfulToken = false;
	          break;
	        case tokens.combinator:
	          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
	            node.operator = content;
	            lastAdded = 'operator';
	          }
	          if (content !== '|') {
	            spaceAfterMeaningfulToken = false;
	            break;
	          }
	          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
	            node.operator = content;
	            lastAdded = 'operator';
	          } else if (!node.namespace && !node.attribute) {
	            node.namespace = true;
	          }
	          spaceAfterMeaningfulToken = false;
	          break;
	        case tokens.word:
	          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals &&
	          // this look-ahead probably fails with comment nodes involved.
	          !node.operator && !node.namespace) {
	            node.namespace = content;
	            lastAdded = 'namespace';
	          } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
	            if (spaceBefore) {
	              (0, _util.ensureObject)(node, 'spaces', 'attribute');
	              node.spaces.attribute.before = spaceBefore;
	              spaceBefore = '';
	            }
	            if (commentBefore) {
	              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
	              node.raws.spaces.attribute.before = commentBefore;
	              commentBefore = '';
	            }
	            node.attribute = (node.attribute || "") + content;
	            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;
	            if (_rawValue) {
	              node.raws.attribute += content;
	            }
	            lastAdded = 'attribute';
	          } else if (!node.value && node.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node.quoteMark)) {
	            var _unescaped = (0, _util.unesc)(content);
	            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';
	            var oldValue = node.value || '';
	            node.value = oldValue + _unescaped;
	            node.quoteMark = null;
	            if (_unescaped !== content || _oldRawValue) {
	              (0, _util.ensureObject)(node, 'raws');
	              node.raws.value = (_oldRawValue || oldValue) + content;
	            }
	            lastAdded = 'value';
	          } else {
	            var insensitive = content === 'i' || content === "I";
	            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {
	              node.insensitive = insensitive;
	              if (!insensitive || content === "I") {
	                (0, _util.ensureObject)(node, 'raws');
	                node.raws.insensitiveFlag = content;
	              }
	              lastAdded = 'insensitive';
	              if (spaceBefore) {
	                (0, _util.ensureObject)(node, 'spaces', 'insensitive');
	                node.spaces.insensitive.before = spaceBefore;
	                spaceBefore = '';
	              }
	              if (commentBefore) {
	                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');
	                node.raws.spaces.insensitive.before = commentBefore;
	                commentBefore = '';
	              }
	            } else if (node.value || node.value === '') {
	              lastAdded = 'value';
	              node.value += content;
	              if (node.raws.value) {
	                node.raws.value += content;
	              }
	            }
	          }
	          spaceAfterMeaningfulToken = false;
	          break;
	        case tokens.str:
	          if (!node.attribute || !node.operator) {
	            return this.error("Expected an attribute followed by an operator preceding the string.", {
	              index: token[_tokenize.FIELDS.START_POS]
	            });
	          }
	          var _unescapeValue = (0, _attribute.unescapeValue)(content),
	            unescaped = _unescapeValue.unescaped,
	            quoteMark = _unescapeValue.quoteMark;
	          node.value = unescaped;
	          node.quoteMark = quoteMark;
	          lastAdded = 'value';
	          (0, _util.ensureObject)(node, 'raws');
	          node.raws.value = content;
	          spaceAfterMeaningfulToken = false;
	          break;
	        case tokens.equals:
	          if (!node.attribute) {
	            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);
	          }
	          if (node.value) {
	            return this.error('Unexpected "=" found; an operator was already defined.', {
	              index: token[_tokenize.FIELDS.START_POS]
	            });
	          }
	          node.operator = node.operator ? node.operator + content : content;
	          lastAdded = 'operator';
	          spaceAfterMeaningfulToken = false;
	          break;
	        case tokens.comment:
	          if (lastAdded) {
	            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {
	              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';
	              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;
	              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);
	              node.raws.spaces[lastAdded].after = rawLastComment + content;
	            } else {
	              var lastValue = node[lastAdded] || '';
	              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;
	              (0, _util.ensureObject)(node, 'raws');
	              node.raws[lastAdded] = rawLastValue + content;
	            }
	          } else {
	            commentBefore = commentBefore + content;
	          }
	          break;
	        default:
	          return this.error("Unexpected \"" + content + "\" found.", {
	            index: token[_tokenize.FIELDS.START_POS]
	          });
	      }
	      pos++;
	    }
	    unescapeProp(node, "attribute");
	    unescapeProp(node, "namespace");
	    this.newNode(new _attribute["default"](node));
	    this.position++;
	  }

	  /**
	   * return a node containing meaningless garbage up to (but not including) the specified token position.
	   * if the token position is negative, all remaining tokens are consumed.
	   *
	   * This returns an array containing a single string node if all whitespace,
	   * otherwise an array of comment nodes with space before and after.
	   *
	   * These tokens are not added to the current selector, the caller can add them or use them to amend
	   * a previous node's space metadata.
	   *
	   * In lossy mode, this returns only comments.
	   */;
	  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
	    if (stopPosition < 0) {
	      stopPosition = this.tokens.length;
	    }
	    var startPosition = this.position;
	    var nodes = [];
	    var space = "";
	    var lastComment = undefined;
	    do {
	      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
	        if (!this.options.lossy) {
	          space += this.content();
	        }
	      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
	        var spaces = {};
	        if (space) {
	          spaces.before = space;
	          space = "";
	        }
	        lastComment = new _comment["default"]({
	          value: this.content(),
	          source: getTokenSource(this.currToken),
	          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
	          spaces: spaces
	        });
	        nodes.push(lastComment);
	      }
	    } while (++this.position < stopPosition);
	    if (space) {
	      if (lastComment) {
	        lastComment.spaces.after = space;
	      } else if (!this.options.lossy) {
	        var firstToken = this.tokens[startPosition];
	        var lastToken = this.tokens[this.position - 1];
	        nodes.push(new _string["default"]({
	          value: '',
	          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
	          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
	          spaces: {
	            before: space,
	            after: ''
	          }
	        }));
	      }
	    }
	    return nodes;
	  }

	  /**
	   *
	   * @param {*} nodes
	   */;
	  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
	    var _this2 = this;
	    if (requiredSpace === void 0) {
	      requiredSpace = false;
	    }
	    var space = "";
	    var rawSpace = "";
	    nodes.forEach(function (n) {
	      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);
	      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);
	      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
	      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
	    });
	    if (rawSpace === space) {
	      rawSpace = undefined;
	    }
	    var result = {
	      space: space,
	      rawSpace: rawSpace
	    };
	    return result;
	  };
	  _proto.isNamedCombinator = function isNamedCombinator(position) {
	    if (position === void 0) {
	      position = this.position;
	    }
	    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
	  };
	  _proto.namedCombinator = function namedCombinator() {
	    if (this.isNamedCombinator()) {
	      var nameRaw = this.content(this.tokens[this.position + 1]);
	      var name = (0, _util.unesc)(nameRaw).toLowerCase();
	      var raws = {};
	      if (name !== nameRaw) {
	        raws.value = "/" + nameRaw + "/";
	      }
	      var node = new _combinator["default"]({
	        value: "/" + name + "/",
	        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
	        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
	        raws: raws
	      });
	      this.position = this.position + 3;
	      return node;
	    } else {
	      this.unexpected();
	    }
	  };
	  _proto.combinator = function combinator() {
	    var _this3 = this;
	    if (this.content() === '|') {
	      return this.namespace();
	    }
	    // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.
	    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
	    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
	      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
	      if (nodes.length > 0) {
	        var last = this.current.last;
	        if (last) {
	          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),
	            space = _this$convertWhitespa.space,
	            rawSpace = _this$convertWhitespa.rawSpace;
	          if (rawSpace !== undefined) {
	            last.rawSpaceAfter += rawSpace;
	          }
	          last.spaces.after += space;
	        } else {
	          nodes.forEach(function (n) {
	            return _this3.newNode(n);
	          });
	        }
	      }
	      return;
	    }
	    var firstToken = this.currToken;
	    var spaceOrDescendantSelectorNodes = undefined;
	    if (nextSigTokenPos > this.position) {
	      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
	    }
	    var node;
	    if (this.isNamedCombinator()) {
	      node = this.namedCombinator();
	    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
	      node = new _combinator["default"]({
	        value: this.content(),
	        source: getTokenSource(this.currToken),
	        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
	      });
	      this.position++;
	    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) ; else if (!spaceOrDescendantSelectorNodes) {
	      this.unexpected();
	    }
	    if (node) {
	      if (spaceOrDescendantSelectorNodes) {
	        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),
	          _space = _this$convertWhitespa2.space,
	          _rawSpace = _this$convertWhitespa2.rawSpace;
	        node.spaces.before = _space;
	        node.rawSpaceBefore = _rawSpace;
	      }
	    } else {
	      // descendant combinator
	      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),
	        _space2 = _this$convertWhitespa3.space,
	        _rawSpace2 = _this$convertWhitespa3.rawSpace;
	      if (!_rawSpace2) {
	        _rawSpace2 = _space2;
	      }
	      var spaces = {};
	      var raws = {
	        spaces: {}
	      };
	      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {
	        spaces.before = _space2.slice(0, _space2.length - 1);
	        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
	      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {
	        spaces.after = _space2.slice(1);
	        raws.spaces.after = _rawSpace2.slice(1);
	      } else {
	        raws.value = _rawSpace2;
	      }
	      node = new _combinator["default"]({
	        value: ' ',
	        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
	        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
	        spaces: spaces,
	        raws: raws
	      });
	    }
	    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
	      node.spaces.after = this.optionalSpace(this.content());
	      this.position++;
	    }
	    return this.newNode(node);
	  };
	  _proto.comma = function comma() {
	    if (this.position === this.tokens.length - 1) {
	      this.root.trailingComma = true;
	      this.position++;
	      return;
	    }
	    this.current._inferEndPosition();
	    var selector = new _selector["default"]({
	      source: {
	        start: tokenStart(this.tokens[this.position + 1])
	      }
	    });
	    this.current.parent.append(selector);
	    this.current = selector;
	    this.position++;
	  };
	  _proto.comment = function comment() {
	    var current = this.currToken;
	    this.newNode(new _comment["default"]({
	      value: this.content(),
	      source: getTokenSource(current),
	      sourceIndex: current[_tokenize.FIELDS.START_POS]
	    }));
	    this.position++;
	  };
	  _proto.error = function error(message, opts) {
	    throw this.root.error(message, opts);
	  };
	  _proto.missingBackslash = function missingBackslash() {
	    return this.error('Expected a backslash preceding the semicolon.', {
	      index: this.currToken[_tokenize.FIELDS.START_POS]
	    });
	  };
	  _proto.missingParenthesis = function missingParenthesis() {
	    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
	  };
	  _proto.missingSquareBracket = function missingSquareBracket() {
	    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
	  };
	  _proto.unexpected = function unexpected() {
	    return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
	  };
	  _proto.unexpectedPipe = function unexpectedPipe() {
	    return this.error("Unexpected '|'.", this.currToken[_tokenize.FIELDS.START_POS]);
	  };
	  _proto.namespace = function namespace() {
	    var before = this.prevToken && this.content(this.prevToken) || true;
	    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
	      this.position++;
	      return this.word(before);
	    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
	      this.position++;
	      return this.universal(before);
	    }
	    this.unexpectedPipe();
	  };
	  _proto.nesting = function nesting() {
	    if (this.nextToken) {
	      var nextContent = this.content(this.nextToken);
	      if (nextContent === "|") {
	        this.position++;
	        return;
	      }
	    }
	    var current = this.currToken;
	    this.newNode(new _nesting["default"]({
	      value: this.content(),
	      source: getTokenSource(current),
	      sourceIndex: current[_tokenize.FIELDS.START_POS]
	    }));
	    this.position++;
	  };
	  _proto.parentheses = function parentheses() {
	    var last = this.current.last;
	    var unbalanced = 1;
	    this.position++;
	    if (last && last.type === types.PSEUDO) {
	      var selector = new _selector["default"]({
	        source: {
	          start: tokenStart(this.tokens[this.position - 1])
	        }
	      });
	      var cache = this.current;
	      last.append(selector);
	      this.current = selector;
	      while (this.position < this.tokens.length && unbalanced) {
	        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
	          unbalanced++;
	        }
	        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
	          unbalanced--;
	        }
	        if (unbalanced) {
	          this.parse();
	        } else {
	          this.current.source.end = tokenEnd(this.currToken);
	          this.current.parent.source.end = tokenEnd(this.currToken);
	          this.position++;
	        }
	      }
	      this.current = cache;
	    } else {
	      // I think this case should be an error. It's used to implement a basic parse of media queries
	      // but I don't think it's a good idea.
	      var parenStart = this.currToken;
	      var parenValue = "(";
	      var parenEnd;
	      while (this.position < this.tokens.length && unbalanced) {
	        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
	          unbalanced++;
	        }
	        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
	          unbalanced--;
	        }
	        parenEnd = this.currToken;
	        parenValue += this.parseParenthesisToken(this.currToken);
	        this.position++;
	      }
	      if (last) {
	        last.appendToPropertyAndEscape("value", parenValue, parenValue);
	      } else {
	        this.newNode(new _string["default"]({
	          value: parenValue,
	          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
	          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
	        }));
	      }
	    }
	    if (unbalanced) {
	      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
	    }
	  };
	  _proto.pseudo = function pseudo() {
	    var _this4 = this;
	    var pseudoStr = '';
	    var startingToken = this.currToken;
	    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
	      pseudoStr += this.content();
	      this.position++;
	    }
	    if (!this.currToken) {
	      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
	    }
	    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
	      this.splitWord(false, function (first, length) {
	        pseudoStr += first;
	        _this4.newNode(new _pseudo["default"]({
	          value: pseudoStr,
	          source: getTokenSourceSpan(startingToken, _this4.currToken),
	          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
	        }));
	        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
	          _this4.error('Misplaced parenthesis.', {
	            index: _this4.nextToken[_tokenize.FIELDS.START_POS]
	          });
	        }
	      });
	    } else {
	      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);
	    }
	  };
	  _proto.space = function space() {
	    var content = this.content();
	    // Handle space before and after the selector
	    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {
	      return node.type === 'comment';
	    })) {
	      this.spaces = this.optionalSpace(content);
	      this.position++;
	    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
	      this.current.last.spaces.after = this.optionalSpace(content);
	      this.position++;
	    } else {
	      this.combinator();
	    }
	  };
	  _proto.string = function string() {
	    var current = this.currToken;
	    this.newNode(new _string["default"]({
	      value: this.content(),
	      source: getTokenSource(current),
	      sourceIndex: current[_tokenize.FIELDS.START_POS]
	    }));
	    this.position++;
	  };
	  _proto.universal = function universal(namespace) {
	    var nextToken = this.nextToken;
	    if (nextToken && this.content(nextToken) === '|') {
	      this.position++;
	      return this.namespace();
	    }
	    var current = this.currToken;
	    this.newNode(new _universal["default"]({
	      value: this.content(),
	      source: getTokenSource(current),
	      sourceIndex: current[_tokenize.FIELDS.START_POS]
	    }), namespace);
	    this.position++;
	  };
	  _proto.splitWord = function splitWord(namespace, firstCallback) {
	    var _this5 = this;
	    var nextToken = this.nextToken;
	    var word = this.content();
	    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
	      this.position++;
	      var current = this.content();
	      word += current;
	      if (current.lastIndexOf('\\') === current.length - 1) {
	        var next = this.nextToken;
	        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
	          word += this.requiredSpace(this.content(next));
	          this.position++;
	        }
	      }
	      nextToken = this.nextToken;
	    }
	    var hasClass = indexesOf(word, '.').filter(function (i) {
	      // Allow escaped dot within class name
	      var escapedDot = word[i - 1] === '\\';
	      // Allow decimal numbers percent in @keyframes
	      var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
	      return !escapedDot && !isKeyframesPercent;
	    });
	    var hasId = indexesOf(word, '#').filter(function (i) {
	      return word[i - 1] !== '\\';
	    });
	    // Eliminate Sass interpolations from the list of id indexes
	    var interpolations = indexesOf(word, '#{');
	    if (interpolations.length) {
	      hasId = hasId.filter(function (hashIndex) {
	        return !~interpolations.indexOf(hashIndex);
	      });
	    }
	    var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
	    indices.forEach(function (ind, i) {
	      var index = indices[i + 1] || word.length;
	      var value = word.slice(ind, index);
	      if (i === 0 && firstCallback) {
	        return firstCallback.call(_this5, value, indices.length);
	      }
	      var node;
	      var current = _this5.currToken;
	      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];
	      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));
	      if (~hasClass.indexOf(ind)) {
	        var classNameOpts = {
	          value: value.slice(1),
	          source: source,
	          sourceIndex: sourceIndex
	        };
	        node = new _className["default"](unescapeProp(classNameOpts, "value"));
	      } else if (~hasId.indexOf(ind)) {
	        var idOpts = {
	          value: value.slice(1),
	          source: source,
	          sourceIndex: sourceIndex
	        };
	        node = new _id["default"](unescapeProp(idOpts, "value"));
	      } else {
	        var tagOpts = {
	          value: value,
	          source: source,
	          sourceIndex: sourceIndex
	        };
	        unescapeProp(tagOpts, "value");
	        node = new _tag["default"](tagOpts);
	      }
	      _this5.newNode(node, namespace);
	      // Ensure that the namespace is used only once
	      namespace = null;
	    });
	    this.position++;
	  };
	  _proto.word = function word(namespace) {
	    var nextToken = this.nextToken;
	    if (nextToken && this.content(nextToken) === '|') {
	      this.position++;
	      return this.namespace();
	    }
	    return this.splitWord(namespace);
	  };
	  _proto.loop = function loop() {
	    while (this.position < this.tokens.length) {
	      this.parse(true);
	    }
	    this.current._inferEndPosition();
	    return this.root;
	  };
	  _proto.parse = function parse(throwOnParenthesis) {
	    switch (this.currToken[_tokenize.FIELDS.TYPE]) {
	      case tokens.space:
	        this.space();
	        break;
	      case tokens.comment:
	        this.comment();
	        break;
	      case tokens.openParenthesis:
	        this.parentheses();
	        break;
	      case tokens.closeParenthesis:
	        if (throwOnParenthesis) {
	          this.missingParenthesis();
	        }
	        break;
	      case tokens.openSquare:
	        this.attribute();
	        break;
	      case tokens.dollar:
	      case tokens.caret:
	      case tokens.equals:
	      case tokens.word:
	        this.word();
	        break;
	      case tokens.colon:
	        this.pseudo();
	        break;
	      case tokens.comma:
	        this.comma();
	        break;
	      case tokens.asterisk:
	        this.universal();
	        break;
	      case tokens.ampersand:
	        this.nesting();
	        break;
	      case tokens.slash:
	      case tokens.combinator:
	        this.combinator();
	        break;
	      case tokens.str:
	        this.string();
	        break;
	      // These cases throw; no break needed.
	      case tokens.closeSquare:
	        this.missingSquareBracket();
	      case tokens.semicolon:
	        this.missingBackslash();
	      default:
	        this.unexpected();
	    }
	  }

	  /**
	   * Helpers
	   */;
	  _proto.expected = function expected(description, index, found) {
	    if (Array.isArray(description)) {
	      var last = description.pop();
	      description = description.join(', ') + " or " + last;
	    }
	    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';
	    if (!found) {
	      return this.error("Expected " + an + " " + description + ".", {
	        index: index
	      });
	    }
	    return this.error("Expected " + an + " " + description + ", found \"" + found + "\" instead.", {
	      index: index
	    });
	  };
	  _proto.requiredSpace = function requiredSpace(space) {
	    return this.options.lossy ? ' ' : space;
	  };
	  _proto.optionalSpace = function optionalSpace(space) {
	    return this.options.lossy ? '' : space;
	  };
	  _proto.lossySpace = function lossySpace(space, required) {
	    if (this.options.lossy) {
	      return required ? ' ' : '';
	    } else {
	      return space;
	    }
	  };
	  _proto.parseParenthesisToken = function parseParenthesisToken(token) {
	    var content = this.content(token);
	    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
	      return this.requiredSpace(content);
	    } else {
	      return content;
	    }
	  };
	  _proto.newNode = function newNode(node, namespace) {
	    if (namespace) {
	      if (/^ +$/.test(namespace)) {
	        if (!this.options.lossy) {
	          this.spaces = (this.spaces || '') + namespace;
	        }
	        namespace = true;
	      }
	      node.namespace = namespace;
	      unescapeProp(node, "namespace");
	    }
	    if (this.spaces) {
	      node.spaces.before = this.spaces;
	      this.spaces = '';
	    }
	    return this.current.append(node);
	  };
	  _proto.content = function content(token) {
	    if (token === void 0) {
	      token = this.currToken;
	    }
	    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
	  };
	  /**
	   * returns the index of the next non-whitespace, non-comment token.
	   * returns -1 if no meaningful token is found.
	   */
	  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
	    if (startPosition === void 0) {
	      startPosition = this.position + 1;
	    }
	    var searchPosition = startPosition;
	    while (searchPosition < this.tokens.length) {
	      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
	        searchPosition++;
	        continue;
	      } else {
	        return searchPosition;
	      }
	    }
	    return -1;
	  };
	  _createClass(Parser, [{
	    key: "currToken",
	    get: function get() {
	      return this.tokens[this.position];
	    }
	  }, {
	    key: "nextToken",
	    get: function get() {
	      return this.tokens[this.position + 1];
	    }
	  }, {
	    key: "prevToken",
	    get: function get() {
	      return this.tokens[this.position - 1];
	    }
	  }]);
	  return Parser;
	}();
	exports["default"] = Parser;
	module.exports = exports.default; 
} (parser, parser.exports));

var parserExports = parser.exports;

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _parser = _interopRequireDefault(parserExports);
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	var Processor = /*#__PURE__*/function () {
	  function Processor(func, options) {
	    this.func = func || function noop() {};
	    this.funcRes = null;
	    this.options = options;
	  }
	  var _proto = Processor.prototype;
	  _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
	    if (options === void 0) {
	      options = {};
	    }
	    var merged = Object.assign({}, this.options, options);
	    if (merged.updateSelector === false) {
	      return false;
	    } else {
	      return typeof rule !== "string";
	    }
	  };
	  _proto._isLossy = function _isLossy(options) {
	    if (options === void 0) {
	      options = {};
	    }
	    var merged = Object.assign({}, this.options, options);
	    if (merged.lossless === false) {
	      return true;
	    } else {
	      return false;
	    }
	  };
	  _proto._root = function _root(rule, options) {
	    if (options === void 0) {
	      options = {};
	    }
	    var parser = new _parser["default"](rule, this._parseOptions(options));
	    return parser.root;
	  };
	  _proto._parseOptions = function _parseOptions(options) {
	    return {
	      lossy: this._isLossy(options)
	    };
	  };
	  _proto._run = function _run(rule, options) {
	    var _this = this;
	    if (options === void 0) {
	      options = {};
	    }
	    return new Promise(function (resolve, reject) {
	      try {
	        var root = _this._root(rule, options);
	        Promise.resolve(_this.func(root)).then(function (transform) {
	          var string = undefined;
	          if (_this._shouldUpdateSelector(rule, options)) {
	            string = root.toString();
	            rule.selector = string;
	          }
	          return {
	            transform: transform,
	            root: root,
	            string: string
	          };
	        }).then(resolve, reject);
	      } catch (e) {
	        reject(e);
	        return;
	      }
	    });
	  };
	  _proto._runSync = function _runSync(rule, options) {
	    if (options === void 0) {
	      options = {};
	    }
	    var root = this._root(rule, options);
	    var transform = this.func(root);
	    if (transform && typeof transform.then === "function") {
	      throw new Error("Selector processor returned a promise to a synchronous call.");
	    }
	    var string = undefined;
	    if (options.updateSelector && typeof rule !== "string") {
	      string = root.toString();
	      rule.selector = string;
	    }
	    return {
	      transform: transform,
	      root: root,
	      string: string
	    };
	  }

	  /**
	   * Process rule into a selector AST.
	   *
	   * @param rule {postcss.Rule | string} The css selector to be processed
	   * @param options The options for processing
	   * @returns {Promise<parser.Root>} The AST of the selector after processing it.
	   */;
	  _proto.ast = function ast(rule, options) {
	    return this._run(rule, options).then(function (result) {
	      return result.root;
	    });
	  }

	  /**
	   * Process rule into a selector AST synchronously.
	   *
	   * @param rule {postcss.Rule | string} The css selector to be processed
	   * @param options The options for processing
	   * @returns {parser.Root} The AST of the selector after processing it.
	   */;
	  _proto.astSync = function astSync(rule, options) {
	    return this._runSync(rule, options).root;
	  }

	  /**
	   * Process a selector into a transformed value asynchronously
	   *
	   * @param rule {postcss.Rule | string} The css selector to be processed
	   * @param options The options for processing
	   * @returns {Promise<any>} The value returned by the processor.
	   */;
	  _proto.transform = function transform(rule, options) {
	    return this._run(rule, options).then(function (result) {
	      return result.transform;
	    });
	  }

	  /**
	   * Process a selector into a transformed value synchronously.
	   *
	   * @param rule {postcss.Rule | string} The css selector to be processed
	   * @param options The options for processing
	   * @returns {any} The value returned by the processor.
	   */;
	  _proto.transformSync = function transformSync(rule, options) {
	    return this._runSync(rule, options).transform;
	  }

	  /**
	   * Process a selector into a new selector string asynchronously.
	   *
	   * @param rule {postcss.Rule | string} The css selector to be processed
	   * @param options The options for processing
	   * @returns {string} the selector after processing.
	   */;
	  _proto.process = function process(rule, options) {
	    return this._run(rule, options).then(function (result) {
	      return result.string || result.root.toString();
	    });
	  }

	  /**
	   * Process a selector into a new selector string synchronously.
	   *
	   * @param rule {postcss.Rule | string} The css selector to be processed
	   * @param options The options for processing
	   * @returns {string} the selector after processing.
	   */;
	  _proto.processSync = function processSync(rule, options) {
	    var result = this._runSync(rule, options);
	    return result.string || result.root.toString();
	  };
	  return Processor;
	}();
	exports["default"] = Processor;
	module.exports = exports.default; 
} (processor, processor.exports));

var processorExports = processor.exports;

var selectors = {};

var constructors = {};

constructors.__esModule = true;
constructors.universal = constructors.tag = constructors.string = constructors.selector = constructors.root = constructors.pseudo = constructors.nesting = constructors.id = constructors.comment = constructors.combinator = constructors.className = constructors.attribute = void 0;
var _attribute = _interopRequireDefault$4(attribute$1);
var _className = _interopRequireDefault$4(classNameExports);
var _combinator = _interopRequireDefault$4(combinatorExports);
var _comment = _interopRequireDefault$4(commentExports);
var _id = _interopRequireDefault$4(idExports);
var _nesting = _interopRequireDefault$4(nestingExports);
var _pseudo = _interopRequireDefault$4(pseudoExports);
var _root = _interopRequireDefault$4(rootExports);
var _selector = _interopRequireDefault$4(selectorExports);
var _string = _interopRequireDefault$4(stringExports);
var _tag = _interopRequireDefault$4(tagExports);
var _universal = _interopRequireDefault$4(universalExports);
function _interopRequireDefault$4(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
var attribute = function attribute(opts) {
  return new _attribute["default"](opts);
};
constructors.attribute = attribute;
var className = function className(opts) {
  return new _className["default"](opts);
};
constructors.className = className;
var combinator = function combinator(opts) {
  return new _combinator["default"](opts);
};
constructors.combinator = combinator;
var comment = function comment(opts) {
  return new _comment["default"](opts);
};
constructors.comment = comment;
var id = function id(opts) {
  return new _id["default"](opts);
};
constructors.id = id;
var nesting = function nesting(opts) {
  return new _nesting["default"](opts);
};
constructors.nesting = nesting;
var pseudo = function pseudo(opts) {
  return new _pseudo["default"](opts);
};
constructors.pseudo = pseudo;
var root$1 = function root(opts) {
  return new _root["default"](opts);
};
constructors.root = root$1;
var selector = function selector(opts) {
  return new _selector["default"](opts);
};
constructors.selector = selector;
var string = function string(opts) {
  return new _string["default"](opts);
};
constructors.string = string;
var tag = function tag(opts) {
  return new _tag["default"](opts);
};
constructors.tag = tag;
var universal = function universal(opts) {
  return new _universal["default"](opts);
};
constructors.universal = universal;

var guards = {};

guards.__esModule = true;
guards.isComment = guards.isCombinator = guards.isClassName = guards.isAttribute = void 0;
guards.isContainer = isContainer;
guards.isIdentifier = void 0;
guards.isNamespace = isNamespace;
guards.isNesting = void 0;
guards.isNode = isNode;
guards.isPseudo = void 0;
guards.isPseudoClass = isPseudoClass;
guards.isPseudoElement = isPseudoElement;
guards.isUniversal = guards.isTag = guards.isString = guards.isSelector = guards.isRoot = void 0;
var _types = types$1;
var _IS_TYPE;
var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
function isNode(node) {
  return typeof node === "object" && IS_TYPE[node.type];
}
function isNodeType(type, node) {
  return isNode(node) && node.type === type;
}
var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
guards.isAttribute = isAttribute;
var isClassName = isNodeType.bind(null, _types.CLASS);
guards.isClassName = isClassName;
var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
guards.isCombinator = isCombinator;
var isComment = isNodeType.bind(null, _types.COMMENT);
guards.isComment = isComment;
var isIdentifier = isNodeType.bind(null, _types.ID);
guards.isIdentifier = isIdentifier;
var isNesting = isNodeType.bind(null, _types.NESTING);
guards.isNesting = isNesting;
var isPseudo = isNodeType.bind(null, _types.PSEUDO);
guards.isPseudo = isPseudo;
var isRoot = isNodeType.bind(null, _types.ROOT);
guards.isRoot = isRoot;
var isSelector = isNodeType.bind(null, _types.SELECTOR);
guards.isSelector = isSelector;
var isString = isNodeType.bind(null, _types.STRING);
guards.isString = isString;
var isTag = isNodeType.bind(null, _types.TAG);
guards.isTag = isTag;
var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
guards.isUniversal = isUniversal;
function isPseudoElement(node) {
  return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after" || node.value.toLowerCase() === ":first-letter" || node.value.toLowerCase() === ":first-line");
}
function isPseudoClass(node) {
  return isPseudo(node) && !isPseudoElement(node);
}
function isContainer(node) {
  return !!(isNode(node) && node.walk);
}
function isNamespace(node) {
  return isAttribute(node) || isTag(node);
}

(function (exports) {

	exports.__esModule = true;
	var _types = types$1;
	Object.keys(_types).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _types[key]) return;
	  exports[key] = _types[key];
	});
	var _constructors = constructors;
	Object.keys(_constructors).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _constructors[key]) return;
	  exports[key] = _constructors[key];
	});
	var _guards = guards;
	Object.keys(_guards).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _guards[key]) return;
	  exports[key] = _guards[key];
	}); 
} (selectors));

(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = void 0;
	var _processor = _interopRequireDefault(processorExports);
	var selectors$1 = _interopRequireWildcard(selectors);
	function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
	function _interopRequireWildcard(obj, nodeInterop) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	var parser = function parser(processor) {
	  return new _processor["default"](processor);
	};
	Object.assign(parser, selectors$1);
	delete parser.__esModule;
	var _default = parser;
	exports["default"] = _default;
	module.exports = exports.default; 
} (dist, dist.exports));

var distExports = dist.exports;
var selectorParser$2 = /*@__PURE__*/getDefaultExportFromCjs(distExports);

const animationNameRE = /^(-\w+-)?animation-name$/;
const animationRE = /^(-\w+-)?animation$/;
const scopedPlugin = (id = "") => {
  const keyframes = /* @__PURE__ */ Object.create(null);
  const shortId = id.replace(/^data-v-/, "");
  return {
    postcssPlugin: "vue-sfc-scoped",
    Rule(rule) {
      processRule(id, rule);
    },
    AtRule(node) {
      if (/-?keyframes$/.test(node.name) && !node.params.endsWith(`-${shortId}`)) {
        keyframes[node.params] = node.params = node.params + "-" + shortId;
      }
    },
    OnceExit(root) {
      if (Object.keys(keyframes).length) {
        root.walkDecls((decl) => {
          if (animationNameRE.test(decl.prop)) {
            decl.value = decl.value.split(",").map((v) => keyframes[v.trim()] || v.trim()).join(",");
          }
          if (animationRE.test(decl.prop)) {
            decl.value = decl.value.split(",").map((v) => {
              const vals = v.trim().split(/\s+/);
              const i = vals.findIndex((val) => keyframes[val]);
              if (i !== -1) {
                vals.splice(i, 1, keyframes[vals[i]]);
                return vals.join(" ");
              } else {
                return v;
              }
            }).join(",");
          }
        });
      }
    }
  };
};
const processedRules = /* @__PURE__ */ new WeakSet();
function processRule(id, rule) {
  if (processedRules.has(rule) || rule.parent && rule.parent.type === "atrule" && /-?keyframes$/.test(rule.parent.name)) {
    return;
  }
  processedRules.add(rule);
  rule.selector = selectorParser$2((selectorRoot) => {
    selectorRoot.each((selector) => {
      rewriteSelector(id, selector, selectorRoot);
    });
  }).processSync(rule.selector);
}
function rewriteSelector(id, selector, selectorRoot, slotted = false) {
  let node = null;
  let shouldInject = true;
  selector.each((n) => {
    if (n.type === "combinator" && (n.value === ">>>" || n.value === "/deep/")) {
      n.value = " ";
      n.spaces.before = n.spaces.after = "";
      warn(
        `the >>> and /deep/ combinators have been deprecated. Use :deep() instead.`
      );
      return false;
    }
    if (n.type === "pseudo") {
      const { value } = n;
      if (value === ":deep" || value === "::v-deep") {
        if (n.nodes.length) {
          let last = n;
          n.nodes[0].each((ss) => {
            selector.insertAfter(last, ss);
            last = ss;
          });
          const prev = selector.at(selector.index(n) - 1);
          if (!prev || !isSpaceCombinator(prev)) {
            selector.insertAfter(
              n,
              selectorParser$2.combinator({
                value: " "
              })
            );
          }
          selector.removeChild(n);
        } else {
          warn(
            `${value} usage as a combinator has been deprecated. Use :deep(<inner-selector>) instead of ${value} <inner-selector>.`
          );
          const prev = selector.at(selector.index(n) - 1);
          if (prev && isSpaceCombinator(prev)) {
            selector.removeChild(prev);
          }
          selector.removeChild(n);
        }
        return false;
      }
      if (value === ":slotted" || value === "::v-slotted") {
        rewriteSelector(
          id,
          n.nodes[0],
          selectorRoot,
          true
          /* slotted */
        );
        let last = n;
        n.nodes[0].each((ss) => {
          selector.insertAfter(last, ss);
          last = ss;
        });
        selector.removeChild(n);
        shouldInject = false;
        return false;
      }
      if (value === ":global" || value === "::v-global") {
        selectorRoot.insertAfter(selector, n.nodes[0]);
        selectorRoot.removeChild(selector);
        return false;
      }
    }
    if (n.type === "universal") {
      const prev = selector.at(selector.index(n) - 1);
      const next = selector.at(selector.index(n) + 1);
      if (!prev) {
        if (next) {
          if (next.type === "combinator" && next.value === " ") {
            selector.removeChild(next);
          }
          selector.removeChild(n);
          return;
        } else {
          node = selectorParser$2.combinator({
            value: ""
          });
          selector.insertBefore(n, node);
          selector.removeChild(n);
          return false;
        }
      }
      if (node)
        return;
    }
    if (n.type !== "pseudo" && n.type !== "combinator" || n.type === "pseudo" && (n.value === ":is" || n.value === ":where") && !node) {
      node = n;
    }
  });
  if (node) {
    const { type, value } = node;
    if (type === "pseudo" && (value === ":is" || value === ":where")) {
      node.nodes.forEach(
        (value2) => rewriteSelector(id, value2, selectorRoot, slotted)
      );
      shouldInject = false;
    }
  }
  if (node) {
    node.spaces.after = "";
  } else {
    selector.first.spaces.before = "";
  }
  if (shouldInject) {
    const idToAdd = slotted ? id + "-s" : id;
    selector.insertAfter(
      // If node is null it means we need to inject [id] at the start
      // insertAfter can handle `null` here
      node,
      selectorParser$2.attribute({
        attribute: idToAdd,
        value: idToAdd,
        raws: {},
        quoteMark: `"`
      })
    );
  }
}
function isSpaceCombinator(node) {
  return node.type === "combinator" && /^\s+$/.test(node.value);
}
scopedPlugin.postcss = true;

var sourceMap$1 = {};

var sourceMapGenerator = {};

var base64Vlq = {};

var base64$1 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
base64$1.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
base64$1.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = base64$1;

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
base64Vlq.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

var util$5 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

(function (exports) {
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	f